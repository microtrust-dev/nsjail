// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#include "config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
extern PROTOBUF_INTERNAL_EXPORT_config_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Exe_config_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_config_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IdMap_config_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_config_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MountPt_config_2eproto;
namespace nsjail {
class IdMapDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IdMap> _instance;
} _IdMap_default_instance_;
class MountPtDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MountPt> _instance;
} _MountPt_default_instance_;
class ExeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Exe> _instance;
} _Exe_default_instance_;
class NsJailConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NsJailConfig> _instance;
} _NsJailConfig_default_instance_;
}  // namespace nsjail
static void InitDefaultsscc_info_Exe_config_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nsjail::_Exe_default_instance_;
    new (ptr) ::nsjail::Exe();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Exe_config_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Exe_config_2eproto}, {}};

static void InitDefaultsscc_info_IdMap_config_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nsjail::_IdMap_default_instance_;
    new (ptr) ::nsjail::IdMap();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_IdMap_config_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_IdMap_config_2eproto}, {}};

static void InitDefaultsscc_info_MountPt_config_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nsjail::_MountPt_default_instance_;
    new (ptr) ::nsjail::MountPt();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MountPt_config_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_MountPt_config_2eproto}, {}};

static void InitDefaultsscc_info_NsJailConfig_config_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::nsjail::_NsJailConfig_default_instance_;
    new (ptr) ::nsjail::NsJailConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_NsJailConfig_config_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_NsJailConfig_config_2eproto}, {
      &scc_info_IdMap_config_2eproto.base,
      &scc_info_MountPt_config_2eproto.base,
      &scc_info_Exe_config_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_config_2eproto[4];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_config_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_config_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_config_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::nsjail::IdMap, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nsjail::IdMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nsjail::IdMap, inside_id_),
  PROTOBUF_FIELD_OFFSET(::nsjail::IdMap, outside_id_),
  PROTOBUF_FIELD_OFFSET(::nsjail::IdMap, count_),
  PROTOBUF_FIELD_OFFSET(::nsjail::IdMap, use_newidmap_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, src_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, prefix_src_env_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, src_content_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, dst_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, prefix_dst_env_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, fstype_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, options_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, is_bind_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, rw_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, is_dir_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, mandatory_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, is_symlink_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, nosuid_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, nodev_),
  PROTOBUF_FIELD_OFFSET(::nsjail::MountPt, noexec_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  14,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::nsjail::Exe, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nsjail::Exe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nsjail::Exe, path_),
  PROTOBUF_FIELD_OFFSET(::nsjail::Exe, arg_),
  PROTOBUF_FIELD_OFFSET(::nsjail::Exe, arg0_),
  PROTOBUF_FIELD_OFFSET(::nsjail::Exe, exec_fd_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, name_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, description_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, mode_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, hostname_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cwd_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, port_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, bindhost_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, max_conns_per_ip_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, time_limit_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, daemon_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, max_cpus_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, log_fd_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, log_file_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, log_level_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, keep_env_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, envar_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, keep_caps_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cap_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, silent_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, skip_setsid_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, stderr_to_null_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, pass_fd_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, disable_no_new_privs_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_as_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_as_type_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_core_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_core_type_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_cpu_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_cpu_type_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_fsize_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_fsize_type_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_nofile_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_nofile_type_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_nproc_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_nproc_type_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_stack_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, rlimit_stack_type_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, disable_rl_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, persona_addr_compat_layout_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, persona_mmap_page_zero_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, persona_read_implies_exec_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, persona_addr_limit_3gb_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, persona_addr_no_randomize_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, clone_newnet_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, clone_newuser_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, clone_newns_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, clone_newpid_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, clone_newipc_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, clone_newuts_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, clone_newcgroup_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, uidmap_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, gidmap_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, mount_proc_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, mount_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, seccomp_policy_file_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, seccomp_string_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, seccomp_log_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_mem_max_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_mem_mount_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_mem_parent_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_pids_max_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_pids_mount_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_pids_parent_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_net_cls_classid_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_net_cls_mount_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_net_cls_parent_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_cpu_ms_per_sec_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_cpu_mount_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroup_cpu_parent_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, cgroupv2_mount_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, use_cgroupv2_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, iface_no_lo_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, iface_own_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, macvlan_iface_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, macvlan_vs_ip_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, macvlan_vs_nm_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, macvlan_vs_gw_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, macvlan_vs_ma_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, nice_level_),
  PROTOBUF_FIELD_OFFSET(::nsjail::NsJailConfig, exec_bin_),
  0,
  ~0u,
  54,
  1,
  2,
  21,
  3,
  22,
  55,
  26,
  23,
  24,
  4,
  25,
  27,
  ~0u,
  28,
  ~0u,
  29,
  36,
  37,
  ~0u,
  38,
  56,
  31,
  30,
  32,
  57,
  33,
  58,
  34,
  59,
  35,
  60,
  62,
  61,
  63,
  39,
  40,
  41,
  42,
  43,
  44,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  ~0u,
  ~0u,
  45,
  ~0u,
  5,
  ~0u,
  46,
  48,
  6,
  7,
  49,
  8,
  9,
  50,
  10,
  11,
  51,
  12,
  13,
  14,
  47,
  52,
  ~0u,
  15,
  16,
  17,
  18,
  19,
  53,
  20,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, sizeof(::nsjail::IdMap)},
  { 13, 33, sizeof(::nsjail::MountPt)},
  { 48, 57, sizeof(::nsjail::Exe)},
  { 61, 146, sizeof(::nsjail::NsJailConfig)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::nsjail::_IdMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::nsjail::_MountPt_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::nsjail::_Exe_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::nsjail::_NsJailConfig_default_instance_),
};

const char descriptor_table_protodef_config_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014config.proto\022\006nsjail\"a\n\005IdMap\022\023\n\tinsid"
  "e_id\030\001 \001(\t:\000\022\024\n\noutside_id\030\002 \001(\t:\000\022\020\n\005co"
  "unt\030\003 \001(\r:\0011\022\033\n\014use_newidmap\030\004 \001(\010:\005fals"
  "e\"\312\002\n\007MountPt\022\r\n\003src\030\001 \001(\t:\000\022\030\n\016prefix_s"
  "rc_env\030\002 \001(\t:\000\022\025\n\013src_content\030\003 \001(\014:\000\022\r\n"
  "\003dst\030\004 \002(\t:\000\022\030\n\016prefix_dst_env\030\005 \001(\t:\000\022\020"
  "\n\006fstype\030\006 \001(\t:\000\022\021\n\007options\030\007 \001(\t:\000\022\026\n\007i"
  "s_bind\030\010 \001(\010:\005false\022\021\n\002rw\030\t \001(\010:\005false\022\016"
  "\n\006is_dir\030\n \001(\010\022\027\n\tmandatory\030\013 \001(\010:\004true\022"
  "\031\n\nis_symlink\030\014 \001(\010:\005false\022\025\n\006nosuid\030\r \001"
  "(\010:\005false\022\024\n\005nodev\030\016 \001(\010:\005false\022\025\n\006noexe"
  "c\030\017 \001(\010:\005false\"F\n\003Exe\022\014\n\004path\030\001 \002(\t\022\013\n\003a"
  "rg\030\002 \003(\t\022\014\n\004arg0\030\003 \001(\t\022\026\n\007exec_fd\030\004 \001(\010:"
  "\005false\"\304\023\n\014NsJailConfig\022\016\n\004name\030\001 \001(\t:\000\022"
  "\023\n\013description\030\002 \003(\t\022 \n\004mode\030\003 \001(\0162\014.nsj"
  "ail.Mode:\004ONCE\022\030\n\010hostname\030\010 \001(\t:\006NSJAIL"
  "\022\016\n\003cwd\030\t \001(\t:\001/\022\017\n\004port\030\n \001(\r:\0010\022\024\n\010bin"
  "dhost\030\013 \001(\t:\002::\022\033\n\020max_conns_per_ip\030\014 \001("
  "\r:\0010\022\027\n\ntime_limit\030\r \001(\r:\003600\022\025\n\006daemon\030"
  "\016 \001(\010:\005false\022\023\n\010max_cpus\030\017 \001(\r:\0010\022\016\n\006log"
  "_fd\030\020 \001(\005\022\020\n\010log_file\030\021 \001(\t\022#\n\tlog_level"
  "\030\022 \001(\0162\020.nsjail.LogLevel\022\027\n\010keep_env\030\023 \001"
  "(\010:\005false\022\r\n\005envar\030\024 \003(\t\022\030\n\tkeep_caps\030\025 "
  "\001(\010:\005false\022\013\n\003cap\030\026 \003(\t\022\025\n\006silent\030\027 \001(\010:"
  "\005false\022\032\n\013skip_setsid\030\030 \001(\010:\005false\022\035\n\016st"
  "derr_to_null\030\031 \001(\010:\005false\022\017\n\007pass_fd\030\032 \003"
  "(\005\022#\n\024disable_no_new_privs\030\033 \001(\010:\005false\022"
  "\027\n\trlimit_as\030\034 \001(\004:\0044096\022-\n\016rlimit_as_ty"
  "pe\030\035 \001(\0162\016.nsjail.RLimit:\005VALUE\022\026\n\013rlimi"
  "t_core\030\036 \001(\004:\0010\022/\n\020rlimit_core_type\030\037 \001("
  "\0162\016.nsjail.RLimit:\005VALUE\022\027\n\nrlimit_cpu\030 "
  " \001(\004:\003600\022.\n\017rlimit_cpu_type\030! \001(\0162\016.nsj"
  "ail.RLimit:\005VALUE\022\027\n\014rlimit_fsize\030\" \001(\004:"
  "\0011\0220\n\021rlimit_fsize_type\030# \001(\0162\016.nsjail.R"
  "Limit:\005VALUE\022\031\n\rrlimit_nofile\030$ \001(\004:\00232\022"
  "1\n\022rlimit_nofile_type\030% \001(\0162\016.nsjail.RLi"
  "mit:\005VALUE\022\032\n\014rlimit_nproc\030& \001(\004:\0041024\022/"
  "\n\021rlimit_nproc_type\030\' \001(\0162\016.nsjail.RLimi"
  "t:\004SOFT\022\027\n\014rlimit_stack\030( \001(\004:\0018\022/\n\021rlim"
  "it_stack_type\030) \001(\0162\016.nsjail.RLimit:\004SOF"
  "T\022\031\n\ndisable_rl\030T \001(\010:\005false\022)\n\032persona_"
  "addr_compat_layout\030* \001(\010:\005false\022%\n\026perso"
  "na_mmap_page_zero\030+ \001(\010:\005false\022(\n\031person"
  "a_read_implies_exec\030, \001(\010:\005false\022%\n\026pers"
  "ona_addr_limit_3gb\030- \001(\010:\005false\022(\n\031perso"
  "na_addr_no_randomize\030. \001(\010:\005false\022\032\n\014clo"
  "ne_newnet\030/ \001(\010:\004true\022\033\n\rclone_newuser\0300"
  " \001(\010:\004true\022\031\n\013clone_newns\0301 \001(\010:\004true\022\032\n"
  "\014clone_newpid\0302 \001(\010:\004true\022\032\n\014clone_newip"
  "c\0303 \001(\010:\004true\022\032\n\014clone_newuts\0304 \001(\010:\004tru"
  "e\022\035\n\017clone_newcgroup\0305 \001(\010:\004true\022\035\n\006uidm"
  "ap\0306 \003(\0132\r.nsjail.IdMap\022\035\n\006gidmap\0307 \003(\0132"
  "\r.nsjail.IdMap\022\031\n\nmount_proc\0308 \001(\010:\005fals"
  "e\022\036\n\005mount\0309 \003(\0132\017.nsjail.MountPt\022\033\n\023sec"
  "comp_policy_file\030: \001(\t\022\026\n\016seccomp_string"
  "\030; \003(\t\022\032\n\013seccomp_log\030< \001(\010:\005false\022\031\n\016cg"
  "roup_mem_max\030= \001(\004:\0010\022/\n\020cgroup_mem_moun"
  "t\030> \001(\t:\025/sys/fs/cgroup/memory\022!\n\021cgroup"
  "_mem_parent\030\? \001(\t:\006NSJAIL\022\032\n\017cgroup_pids"
  "_max\030@ \001(\004:\0010\022.\n\021cgroup_pids_mount\030A \001(\t"
  ":\023/sys/fs/cgroup/pids\022\"\n\022cgroup_pids_par"
  "ent\030B \001(\t:\006NSJAIL\022!\n\026cgroup_net_cls_clas"
  "sid\030C \001(\r:\0010\0224\n\024cgroup_net_cls_mount\030D \001"
  "(\t:\026/sys/fs/cgroup/net_cls\022%\n\025cgroup_net"
  "_cls_parent\030E \001(\t:\006NSJAIL\022 \n\025cgroup_cpu_"
  "ms_per_sec\030F \001(\r:\0010\022,\n\020cgroup_cpu_mount\030"
  "G \001(\t:\022/sys/fs/cgroup/cpu\022!\n\021cgroup_cpu_"
  "parent\030H \001(\t:\006NSJAIL\022&\n\016cgroupv2_mount\030I"
  " \001(\t:\016/sys/fs/cgroup\022\033\n\014use_cgroupv2\030J \001"
  "(\010:\005false\022\032\n\013iface_no_lo\030K \001(\010:\005false\022\021\n"
  "\tiface_own\030L \003(\t\022\025\n\rmacvlan_iface\030M \001(\t\022"
  "\"\n\rmacvlan_vs_ip\030N \001(\t:\013192.168.0.2\022$\n\rm"
  "acvlan_vs_nm\030O \001(\t:\r255.255.255.0\022\"\n\rmac"
  "vlan_vs_gw\030P \001(\t:\013192.168.0.1\022\027\n\rmacvlan"
  "_vs_ma\030Q \001(\t:\000\022\026\n\nnice_level\030R \001(\005:\00219\022\035"
  "\n\010exec_bin\030S \001(\0132\013.nsjail.Exe*3\n\004Mode\022\n\n"
  "\006LISTEN\020\000\022\010\n\004ONCE\020\001\022\t\n\005RERUN\020\002\022\n\n\006EXECVE"
  "\020\003*B\n\010LogLevel\022\t\n\005DEBUG\020\000\022\010\n\004INFO\020\001\022\013\n\007W"
  "ARNING\020\002\022\t\n\005ERROR\020\003\022\t\n\005FATAL\020\004*0\n\006RLimit"
  "\022\t\n\005VALUE\020\000\022\010\n\004SOFT\020\001\022\010\n\004HARD\020\002\022\007\n\003INF\020\003"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_config_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_config_2eproto_sccs[4] = {
  &scc_info_Exe_config_2eproto.base,
  &scc_info_IdMap_config_2eproto.base,
  &scc_info_MountPt_config_2eproto.base,
  &scc_info_NsJailConfig_config_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_config_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_config_2eproto = {
  false, false, descriptor_table_protodef_config_2eproto, "config.proto", 3200,
  &descriptor_table_config_2eproto_once, descriptor_table_config_2eproto_sccs, descriptor_table_config_2eproto_deps, 4, 0,
  schemas, file_default_instances, TableStruct_config_2eproto::offsets,
  file_level_metadata_config_2eproto, 4, file_level_enum_descriptors_config_2eproto, file_level_service_descriptors_config_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_config_2eproto(&descriptor_table_config_2eproto);
namespace nsjail {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_config_2eproto);
  return file_level_enum_descriptors_config_2eproto[0];
}
bool Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_config_2eproto);
  return file_level_enum_descriptors_config_2eproto[1];
}
bool LogLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RLimit_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_config_2eproto);
  return file_level_enum_descriptors_config_2eproto[2];
}
bool RLimit_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class IdMap::_Internal {
 public:
  using HasBits = decltype(std::declval<IdMap>()._has_bits_);
  static void set_has_inside_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_outside_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_use_newidmap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IdMap::IdMap(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:nsjail.IdMap)
}
IdMap::IdMap(const IdMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  inside_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_inside_id()) {
    inside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_inside_id(), 
      GetArena());
  }
  outside_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_outside_id()) {
    outside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_outside_id(), 
      GetArena());
  }
  ::memcpy(&use_newidmap_, &from.use_newidmap_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&use_newidmap_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:nsjail.IdMap)
}

void IdMap::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IdMap_config_2eproto.base);
  inside_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outside_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  use_newidmap_ = false;
  count_ = 1u;
}

IdMap::~IdMap() {
  // @@protoc_insertion_point(destructor:nsjail.IdMap)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void IdMap::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  inside_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outside_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IdMap::ArenaDtor(void* object) {
  IdMap* _this = reinterpret_cast< IdMap* >(object);
  (void)_this;
}
void IdMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IdMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IdMap& IdMap::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IdMap_config_2eproto.base);
  return *internal_default_instance();
}


void IdMap::Clear() {
// @@protoc_insertion_point(message_clear_start:nsjail.IdMap)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      inside_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      outside_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    use_newidmap_ = false;
    count_ = 1u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IdMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string inside_id = 1 [default = ""];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_inside_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.IdMap.inside_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string outside_id = 2 [default = ""];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_outside_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.IdMap.outside_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 count = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_newidmap = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_use_newidmap(&has_bits);
          use_newidmap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* IdMap::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsjail.IdMap)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string inside_id = 1 [default = ""];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_inside_id().data(), static_cast<int>(this->_internal_inside_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.IdMap.inside_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_inside_id(), target);
  }

  // optional string outside_id = 2 [default = ""];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_outside_id().data(), static_cast<int>(this->_internal_outside_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.IdMap.outside_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_outside_id(), target);
  }

  // optional uint32 count = 3 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  // optional bool use_newidmap = 4 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_use_newidmap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsjail.IdMap)
  return target;
}

size_t IdMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nsjail.IdMap)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string inside_id = 1 [default = ""];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_inside_id());
    }

    // optional string outside_id = 2 [default = ""];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_outside_id());
    }

    // optional bool use_newidmap = 4 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 count = 3 [default = 1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IdMap::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nsjail.IdMap)
  GOOGLE_DCHECK_NE(&from, this);
  const IdMap* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<IdMap>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nsjail.IdMap)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nsjail.IdMap)
    MergeFrom(*source);
  }
}

void IdMap::MergeFrom(const IdMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nsjail.IdMap)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_inside_id(from._internal_inside_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_outside_id(from._internal_outside_id());
    }
    if (cached_has_bits & 0x00000004u) {
      use_newidmap_ = from.use_newidmap_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IdMap::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nsjail.IdMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IdMap::CopyFrom(const IdMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nsjail.IdMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IdMap::IsInitialized() const {
  return true;
}

void IdMap::InternalSwap(IdMap* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  inside_id_.Swap(&other->inside_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  outside_id_.Swap(&other->outside_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(use_newidmap_, other->use_newidmap_);
  swap(count_, other->count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IdMap::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class MountPt::_Internal {
 public:
  using HasBits = decltype(std::declval<MountPt>()._has_bits_);
  static void set_has_src(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prefix_src_env(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_src_content(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dst(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prefix_dst_env(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fstype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_options(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_bind(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_rw(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_mandatory(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_symlink(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_nosuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_nodev(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_noexec(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

MountPt::MountPt(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:nsjail.MountPt)
}
MountPt::MountPt(const MountPt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  src_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_src()) {
    src_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_src(), 
      GetArena());
  }
  prefix_src_env_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_prefix_src_env()) {
    prefix_src_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_prefix_src_env(), 
      GetArena());
  }
  src_content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_src_content()) {
    src_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_src_content(), 
      GetArena());
  }
  dst_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_dst()) {
    dst_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_dst(), 
      GetArena());
  }
  prefix_dst_env_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_prefix_dst_env()) {
    prefix_dst_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_prefix_dst_env(), 
      GetArena());
  }
  fstype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_fstype()) {
    fstype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_fstype(), 
      GetArena());
  }
  options_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_options()) {
    options_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_options(), 
      GetArena());
  }
  ::memcpy(&is_bind_, &from.is_bind_,
    static_cast<size_t>(reinterpret_cast<char*>(&mandatory_) -
    reinterpret_cast<char*>(&is_bind_)) + sizeof(mandatory_));
  // @@protoc_insertion_point(copy_constructor:nsjail.MountPt)
}

void MountPt::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MountPt_config_2eproto.base);
  src_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_src_env_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  src_content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  dst_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_dst_env_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fstype_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  options_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&is_bind_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&noexec_) -
      reinterpret_cast<char*>(&is_bind_)) + sizeof(noexec_));
  mandatory_ = true;
}

MountPt::~MountPt() {
  // @@protoc_insertion_point(destructor:nsjail.MountPt)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MountPt::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  src_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_src_env_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  src_content_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  dst_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_dst_env_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fstype_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  options_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MountPt::ArenaDtor(void* object) {
  MountPt* _this = reinterpret_cast< MountPt* >(object);
  (void)_this;
}
void MountPt::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MountPt::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MountPt& MountPt::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MountPt_config_2eproto.base);
  return *internal_default_instance();
}


void MountPt::Clear() {
// @@protoc_insertion_point(message_clear_start:nsjail.MountPt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      src_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      prefix_src_env_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      src_content_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      dst_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      prefix_dst_env_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      fstype_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      options_.ClearNonDefaultToEmpty();
    }
  }
  is_bind_ = false;
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&rw_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&noexec_) -
        reinterpret_cast<char*>(&rw_)) + sizeof(noexec_));
    mandatory_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MountPt::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string src = 1 [default = ""];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_src();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.MountPt.src");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string prefix_src_env = 2 [default = ""];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_prefix_src_env();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.MountPt.prefix_src_env");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes src_content = 3 [default = ""];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_src_content();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string dst = 4 [default = ""];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_dst();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.MountPt.dst");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string prefix_dst_env = 5 [default = ""];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_prefix_dst_env();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.MountPt.prefix_dst_env");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string fstype = 6 [default = ""];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_fstype();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.MountPt.fstype");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string options = 7 [default = ""];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_options();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.MountPt.options");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_bind = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_is_bind(&has_bits);
          is_bind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool rw = 9 [default = false];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_rw(&has_bits);
          rw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_dir = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_is_dir(&has_bits);
          is_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool mandatory = 11 [default = true];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_mandatory(&has_bits);
          mandatory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_symlink = 12 [default = false];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_is_symlink(&has_bits);
          is_symlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool nosuid = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_nosuid(&has_bits);
          nosuid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool nodev = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_nodev(&has_bits);
          nodev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool noexec = 15 [default = false];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_noexec(&has_bits);
          noexec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MountPt::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsjail.MountPt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string src = 1 [default = ""];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_src().data(), static_cast<int>(this->_internal_src().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.MountPt.src");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_src(), target);
  }

  // optional string prefix_src_env = 2 [default = ""];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prefix_src_env().data(), static_cast<int>(this->_internal_prefix_src_env().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.MountPt.prefix_src_env");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_prefix_src_env(), target);
  }

  // optional bytes src_content = 3 [default = ""];
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_src_content(), target);
  }

  // required string dst = 4 [default = ""];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dst().data(), static_cast<int>(this->_internal_dst().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.MountPt.dst");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_dst(), target);
  }

  // optional string prefix_dst_env = 5 [default = ""];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_prefix_dst_env().data(), static_cast<int>(this->_internal_prefix_dst_env().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.MountPt.prefix_dst_env");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_prefix_dst_env(), target);
  }

  // optional string fstype = 6 [default = ""];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_fstype().data(), static_cast<int>(this->_internal_fstype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.MountPt.fstype");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_fstype(), target);
  }

  // optional string options = 7 [default = ""];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_options().data(), static_cast<int>(this->_internal_options().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.MountPt.options");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_options(), target);
  }

  // optional bool is_bind = 8 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_bind(), target);
  }

  // optional bool rw = 9 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_rw(), target);
  }

  // optional bool is_dir = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_dir(), target);
  }

  // optional bool mandatory = 11 [default = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_mandatory(), target);
  }

  // optional bool is_symlink = 12 [default = false];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_symlink(), target);
  }

  // optional bool nosuid = 13 [default = false];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_nosuid(), target);
  }

  // optional bool nodev = 14 [default = false];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_nodev(), target);
  }

  // optional bool noexec = 15 [default = false];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_noexec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsjail.MountPt)
  return target;
}

size_t MountPt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nsjail.MountPt)
  size_t total_size = 0;

  // required string dst = 4 [default = ""];
  if (_internal_has_dst()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dst());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string src = 1 [default = ""];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_src());
    }

    // optional string prefix_src_env = 2 [default = ""];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prefix_src_env());
    }

    // optional bytes src_content = 3 [default = ""];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_src_content());
    }

  }
  if (cached_has_bits & 0x000000f0u) {
    // optional string prefix_dst_env = 5 [default = ""];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prefix_dst_env());
    }

    // optional string fstype = 6 [default = ""];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fstype());
    }

    // optional string options = 7 [default = ""];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_options());
    }

    // optional bool is_bind = 8 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool rw = 9 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool is_dir = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_symlink = 12 [default = false];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool nosuid = 13 [default = false];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool nodev = 14 [default = false];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool noexec = 15 [default = false];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool mandatory = 11 [default = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MountPt::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nsjail.MountPt)
  GOOGLE_DCHECK_NE(&from, this);
  const MountPt* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MountPt>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nsjail.MountPt)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nsjail.MountPt)
    MergeFrom(*source);
  }
}

void MountPt::MergeFrom(const MountPt& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nsjail.MountPt)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_src(from._internal_src());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_prefix_src_env(from._internal_prefix_src_env());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_src_content(from._internal_src_content());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_dst(from._internal_dst());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_prefix_dst_env(from._internal_prefix_dst_env());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_fstype(from._internal_fstype());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_options(from._internal_options());
    }
    if (cached_has_bits & 0x00000080u) {
      is_bind_ = from.is_bind_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      rw_ = from.rw_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_dir_ = from.is_dir_;
    }
    if (cached_has_bits & 0x00000400u) {
      is_symlink_ = from.is_symlink_;
    }
    if (cached_has_bits & 0x00000800u) {
      nosuid_ = from.nosuid_;
    }
    if (cached_has_bits & 0x00001000u) {
      nodev_ = from.nodev_;
    }
    if (cached_has_bits & 0x00002000u) {
      noexec_ = from.noexec_;
    }
    if (cached_has_bits & 0x00004000u) {
      mandatory_ = from.mandatory_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MountPt::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nsjail.MountPt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MountPt::CopyFrom(const MountPt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nsjail.MountPt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MountPt::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void MountPt::InternalSwap(MountPt* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  src_.Swap(&other->src_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  prefix_src_env_.Swap(&other->prefix_src_env_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  src_content_.Swap(&other->src_content_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  dst_.Swap(&other->dst_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  prefix_dst_env_.Swap(&other->prefix_dst_env_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  fstype_.Swap(&other->fstype_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  options_.Swap(&other->options_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MountPt, noexec_)
      + sizeof(MountPt::noexec_)
      - PROTOBUF_FIELD_OFFSET(MountPt, is_bind_)>(
          reinterpret_cast<char*>(&is_bind_),
          reinterpret_cast<char*>(&other->is_bind_));
  swap(mandatory_, other->mandatory_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MountPt::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Exe::_Internal {
 public:
  using HasBits = decltype(std::declval<Exe>()._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_arg0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_exec_fd(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Exe::Exe(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  arg_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:nsjail.Exe)
}
Exe::Exe(const Exe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      arg_(from.arg_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_path()) {
    path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_path(), 
      GetArena());
  }
  arg0_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_arg0()) {
    arg0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_arg0(), 
      GetArena());
  }
  exec_fd_ = from.exec_fd_;
  // @@protoc_insertion_point(copy_constructor:nsjail.Exe)
}

void Exe::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Exe_config_2eproto.base);
  path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  arg0_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  exec_fd_ = false;
}

Exe::~Exe() {
  // @@protoc_insertion_point(destructor:nsjail.Exe)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Exe::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  arg0_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Exe::ArenaDtor(void* object) {
  Exe* _this = reinterpret_cast< Exe* >(object);
  (void)_this;
}
void Exe::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Exe::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Exe& Exe::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Exe_config_2eproto.base);
  return *internal_default_instance();
}


void Exe::Clear() {
// @@protoc_insertion_point(message_clear_start:nsjail.Exe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  arg_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      arg0_.ClearNonDefaultToEmpty();
    }
  }
  exec_fd_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Exe::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.Exe.path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string arg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_arg();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.Exe.arg");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string arg0 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_arg0();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.Exe.arg0");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool exec_fd = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_exec_fd(&has_bits);
          exec_fd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Exe::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsjail.Exe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string path = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.Exe.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // repeated string arg = 2;
  for (int i = 0, n = this->_internal_arg_size(); i < n; i++) {
    const auto& s = this->_internal_arg(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.Exe.arg");
    target = stream->WriteString(2, s, target);
  }

  // optional string arg0 = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_arg0().data(), static_cast<int>(this->_internal_arg0().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.Exe.arg0");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_arg0(), target);
  }

  // optional bool exec_fd = 4 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_exec_fd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsjail.Exe)
  return target;
}

size_t Exe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nsjail.Exe)
  size_t total_size = 0;

  // required string path = 1;
  if (_internal_has_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string arg = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(arg_.size());
  for (int i = 0, n = arg_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      arg_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string arg0 = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_arg0());
    }

    // optional bool exec_fd = 4 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Exe::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nsjail.Exe)
  GOOGLE_DCHECK_NE(&from, this);
  const Exe* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Exe>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nsjail.Exe)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nsjail.Exe)
    MergeFrom(*source);
  }
}

void Exe::MergeFrom(const Exe& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nsjail.Exe)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  arg_.MergeFrom(from.arg_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_arg0(from._internal_arg0());
    }
    if (cached_has_bits & 0x00000004u) {
      exec_fd_ = from.exec_fd_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Exe::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nsjail.Exe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Exe::CopyFrom(const Exe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nsjail.Exe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Exe::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Exe::InternalSwap(Exe* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  arg_.InternalSwap(&other->arg_);
  path_.Swap(&other->path_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  arg0_.Swap(&other->arg0_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(exec_fd_, other->exec_fd_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Exe::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class NsJailConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<NsJailConfig>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cwd(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_bindhost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_conns_per_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_time_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_daemon(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_max_cpus(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_log_fd(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_log_file(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_log_level(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_keep_env(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_keep_caps(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_silent(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_skip_setsid(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_stderr_to_null(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_disable_no_new_privs(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_rlimit_as(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_rlimit_as_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_rlimit_core(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_rlimit_core_type(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_rlimit_cpu(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static void set_has_rlimit_cpu_type(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_rlimit_fsize(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_rlimit_fsize_type(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_rlimit_nofile(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static void set_has_rlimit_nofile_type(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_rlimit_nproc(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static void set_has_rlimit_nproc_type(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static void set_has_rlimit_stack(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static void set_has_rlimit_stack_type(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static void set_has_disable_rl(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_persona_addr_compat_layout(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_persona_mmap_page_zero(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_persona_read_implies_exec(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_persona_addr_limit_3gb(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_persona_addr_no_randomize(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_clone_newnet(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static void set_has_clone_newuser(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static void set_has_clone_newns(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static void set_has_clone_newpid(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static void set_has_clone_newipc(HasBits* has_bits) {
    (*has_bits)[2] |= 16u;
  }
  static void set_has_clone_newuts(HasBits* has_bits) {
    (*has_bits)[2] |= 32u;
  }
  static void set_has_clone_newcgroup(HasBits* has_bits) {
    (*has_bits)[2] |= 64u;
  }
  static void set_has_mount_proc(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_seccomp_policy_file(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_seccomp_log(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_cgroup_mem_max(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_cgroup_mem_mount(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_cgroup_mem_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_cgroup_pids_max(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_cgroup_pids_mount(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_cgroup_pids_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cgroup_net_cls_classid(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_cgroup_net_cls_mount(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_cgroup_net_cls_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_cgroup_cpu_ms_per_sec(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_cgroup_cpu_mount(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_cgroup_cpu_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_cgroupv2_mount(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_use_cgroupv2(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_iface_no_lo(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_macvlan_iface(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_macvlan_vs_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_macvlan_vs_nm(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_macvlan_vs_gw(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_macvlan_vs_ma(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_nice_level(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static const ::nsjail::Exe& exec_bin(const NsJailConfig* msg);
  static void set_has_exec_bin(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
};

const ::nsjail::Exe&
NsJailConfig::_Internal::exec_bin(const NsJailConfig* msg) {
  return *msg->exec_bin_;
}
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_{{{"NSJAIL", 6}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_{{{"/", 1}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_{{{"::", 2}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_{{{"/sys/fs/cgroup/memory", 21}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_{{{"NSJAIL", 6}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_{{{"/sys/fs/cgroup/pids", 19}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_{{{"NSJAIL", 6}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_{{{"/sys/fs/cgroup/net_cls", 22}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_{{{"NSJAIL", 6}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_{{{"/sys/fs/cgroup/cpu", 18}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_{{{"NSJAIL", 6}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_{{{"/sys/fs/cgroup", 14}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_{{{"192.168.0.2", 11}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_{{{"255.255.255.0", 13}}, {nullptr}};
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_{{{"192.168.0.1", 11}}, {nullptr}};
NsJailConfig::NsJailConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  description_(arena),
  envar_(arena),
  cap_(arena),
  pass_fd_(arena),
  uidmap_(arena),
  gidmap_(arena),
  mount_(arena),
  seccomp_string_(arena),
  iface_own_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:nsjail.NsJailConfig)
}
NsJailConfig::NsJailConfig(const NsJailConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      description_(from.description_),
      envar_(from.envar_),
      cap_(from.cap_),
      pass_fd_(from.pass_fd_),
      uidmap_(from.uidmap_),
      gidmap_(from.gidmap_),
      mount_(from.mount_),
      seccomp_string_(from.seccomp_string_),
      iface_own_(from.iface_own_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArena());
  }
  hostname_.UnsafeSetDefault(nullptr);
  if (from._internal_has_hostname()) {
    hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_hostname(), 
      GetArena());
  }
  cwd_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cwd()) {
    cwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cwd(), 
      GetArena());
  }
  bindhost_.UnsafeSetDefault(nullptr);
  if (from._internal_has_bindhost()) {
    bindhost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_bindhost(), 
      GetArena());
  }
  log_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_log_file()) {
    log_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_log_file(), 
      GetArena());
  }
  seccomp_policy_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_seccomp_policy_file()) {
    seccomp_policy_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_seccomp_policy_file(), 
      GetArena());
  }
  cgroup_mem_mount_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_mem_mount()) {
    cgroup_mem_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_mem_mount(), 
      GetArena());
  }
  cgroup_mem_parent_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_mem_parent()) {
    cgroup_mem_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_mem_parent(), 
      GetArena());
  }
  cgroup_pids_mount_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_pids_mount()) {
    cgroup_pids_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_pids_mount(), 
      GetArena());
  }
  cgroup_pids_parent_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_pids_parent()) {
    cgroup_pids_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_pids_parent(), 
      GetArena());
  }
  cgroup_net_cls_mount_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_net_cls_mount()) {
    cgroup_net_cls_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_net_cls_mount(), 
      GetArena());
  }
  cgroup_net_cls_parent_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_net_cls_parent()) {
    cgroup_net_cls_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_net_cls_parent(), 
      GetArena());
  }
  cgroup_cpu_mount_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_cpu_mount()) {
    cgroup_cpu_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_cpu_mount(), 
      GetArena());
  }
  cgroup_cpu_parent_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroup_cpu_parent()) {
    cgroup_cpu_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroup_cpu_parent(), 
      GetArena());
  }
  cgroupv2_mount_.UnsafeSetDefault(nullptr);
  if (from._internal_has_cgroupv2_mount()) {
    cgroupv2_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_cgroupv2_mount(), 
      GetArena());
  }
  macvlan_iface_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_macvlan_iface()) {
    macvlan_iface_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_macvlan_iface(), 
      GetArena());
  }
  macvlan_vs_ip_.UnsafeSetDefault(nullptr);
  if (from._internal_has_macvlan_vs_ip()) {
    macvlan_vs_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_macvlan_vs_ip(), 
      GetArena());
  }
  macvlan_vs_nm_.UnsafeSetDefault(nullptr);
  if (from._internal_has_macvlan_vs_nm()) {
    macvlan_vs_nm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_macvlan_vs_nm(), 
      GetArena());
  }
  macvlan_vs_gw_.UnsafeSetDefault(nullptr);
  if (from._internal_has_macvlan_vs_gw()) {
    macvlan_vs_gw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_macvlan_vs_gw(), 
      GetArena());
  }
  macvlan_vs_ma_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_macvlan_vs_ma()) {
    macvlan_vs_ma_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_macvlan_vs_ma(), 
      GetArena());
  }
  if (from._internal_has_exec_bin()) {
    exec_bin_ = new ::nsjail::Exe(*from.exec_bin_);
  } else {
    exec_bin_ = nullptr;
  }
  ::memcpy(&port_, &from.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&clone_newcgroup_) -
    reinterpret_cast<char*>(&port_)) + sizeof(clone_newcgroup_));
  // @@protoc_insertion_point(copy_constructor:nsjail.NsJailConfig)
}

void NsJailConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NsJailConfig_config_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hostname_.UnsafeSetDefault(nullptr);
  cwd_.UnsafeSetDefault(nullptr);
  bindhost_.UnsafeSetDefault(nullptr);
  log_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  seccomp_policy_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cgroup_mem_mount_.UnsafeSetDefault(nullptr);
  cgroup_mem_parent_.UnsafeSetDefault(nullptr);
  cgroup_pids_mount_.UnsafeSetDefault(nullptr);
  cgroup_pids_parent_.UnsafeSetDefault(nullptr);
  cgroup_net_cls_mount_.UnsafeSetDefault(nullptr);
  cgroup_net_cls_parent_.UnsafeSetDefault(nullptr);
  cgroup_cpu_mount_.UnsafeSetDefault(nullptr);
  cgroup_cpu_parent_.UnsafeSetDefault(nullptr);
  cgroupv2_mount_.UnsafeSetDefault(nullptr);
  macvlan_iface_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  macvlan_vs_ip_.UnsafeSetDefault(nullptr);
  macvlan_vs_nm_.UnsafeSetDefault(nullptr);
  macvlan_vs_gw_.UnsafeSetDefault(nullptr);
  macvlan_vs_ma_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&exec_bin_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&iface_no_lo_) -
      reinterpret_cast<char*>(&exec_bin_)) + sizeof(iface_no_lo_));
  nice_level_ = 19;
  mode_ = 1;
  time_limit_ = 600u;
  rlimit_as_ = PROTOBUF_ULONGLONG(4096);
  rlimit_cpu_ = PROTOBUF_ULONGLONG(600);
  rlimit_fsize_ = PROTOBUF_ULONGLONG(1);
  rlimit_nofile_ = PROTOBUF_ULONGLONG(32);
  rlimit_nproc_ = PROTOBUF_ULONGLONG(1024);
  rlimit_stack_ = PROTOBUF_ULONGLONG(8);
  rlimit_nproc_type_ = 1;
  rlimit_stack_type_ = 1;
  clone_newnet_ = true;
  clone_newuser_ = true;
  clone_newns_ = true;
  clone_newpid_ = true;
  clone_newipc_ = true;
  clone_newuts_ = true;
  clone_newcgroup_ = true;
}

NsJailConfig::~NsJailConfig() {
  // @@protoc_insertion_point(destructor:nsjail.NsJailConfig)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void NsJailConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hostname_.DestroyNoArena(nullptr);
  cwd_.DestroyNoArena(nullptr);
  bindhost_.DestroyNoArena(nullptr);
  log_file_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  seccomp_policy_file_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cgroup_mem_mount_.DestroyNoArena(nullptr);
  cgroup_mem_parent_.DestroyNoArena(nullptr);
  cgroup_pids_mount_.DestroyNoArena(nullptr);
  cgroup_pids_parent_.DestroyNoArena(nullptr);
  cgroup_net_cls_mount_.DestroyNoArena(nullptr);
  cgroup_net_cls_parent_.DestroyNoArena(nullptr);
  cgroup_cpu_mount_.DestroyNoArena(nullptr);
  cgroup_cpu_parent_.DestroyNoArena(nullptr);
  cgroupv2_mount_.DestroyNoArena(nullptr);
  macvlan_iface_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  macvlan_vs_ip_.DestroyNoArena(nullptr);
  macvlan_vs_nm_.DestroyNoArena(nullptr);
  macvlan_vs_gw_.DestroyNoArena(nullptr);
  macvlan_vs_ma_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete exec_bin_;
}

void NsJailConfig::ArenaDtor(void* object) {
  NsJailConfig* _this = reinterpret_cast< NsJailConfig* >(object);
  (void)_this;
}
void NsJailConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NsJailConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NsJailConfig& NsJailConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NsJailConfig_config_2eproto.base);
  return *internal_default_instance();
}


void NsJailConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:nsjail.NsJailConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  description_.Clear();
  envar_.Clear();
  cap_.Clear();
  pass_fd_.Clear();
  uidmap_.Clear();
  gidmap_.Clear();
  mount_.Clear();
  seccomp_string_.Clear();
  iface_own_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      hostname_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_, GetArena());
       }
    if (cached_has_bits & 0x00000004u) {
      cwd_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_, GetArena());
       }
    if (cached_has_bits & 0x00000008u) {
      bindhost_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_, GetArena());
       }
    if (cached_has_bits & 0x00000010u) {
      log_file_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      seccomp_policy_file_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      cgroup_mem_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_, GetArena());
       }
    if (cached_has_bits & 0x00000080u) {
      cgroup_mem_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_, GetArena());
       }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      cgroup_pids_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_, GetArena());
       }
    if (cached_has_bits & 0x00000200u) {
      cgroup_pids_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_, GetArena());
       }
    if (cached_has_bits & 0x00000400u) {
      cgroup_net_cls_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_, GetArena());
       }
    if (cached_has_bits & 0x00000800u) {
      cgroup_net_cls_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_, GetArena());
       }
    if (cached_has_bits & 0x00001000u) {
      cgroup_cpu_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_, GetArena());
       }
    if (cached_has_bits & 0x00002000u) {
      cgroup_cpu_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_, GetArena());
       }
    if (cached_has_bits & 0x00004000u) {
      cgroupv2_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_, GetArena());
       }
    if (cached_has_bits & 0x00008000u) {
      macvlan_iface_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      macvlan_vs_ip_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_, GetArena());
       }
    if (cached_has_bits & 0x00020000u) {
      macvlan_vs_nm_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_, GetArena());
       }
    if (cached_has_bits & 0x00040000u) {
      macvlan_vs_gw_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_, GetArena());
       }
    if (cached_has_bits & 0x00080000u) {
      macvlan_vs_ma_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(exec_bin_ != nullptr);
      exec_bin_->Clear();
    }
  }
  if (cached_has_bits & 0x00e00000u) {
    ::memset(&port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_cpus_) -
        reinterpret_cast<char*>(&port_)) + sizeof(max_cpus_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&log_fd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rlimit_as_type_) -
        reinterpret_cast<char*>(&log_fd_)) + sizeof(rlimit_as_type_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&rlimit_core_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&disable_rl_) -
        reinterpret_cast<char*>(&rlimit_core_type_)) + sizeof(disable_rl_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&persona_addr_compat_layout_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_cgroupv2_) -
        reinterpret_cast<char*>(&persona_addr_compat_layout_)) + sizeof(use_cgroupv2_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&cgroup_mem_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&iface_no_lo_) -
        reinterpret_cast<char*>(&cgroup_mem_max_)) + sizeof(iface_no_lo_));
    nice_level_ = 19;
    mode_ = 1;
    time_limit_ = 600u;
  }
  if (cached_has_bits & 0xff000000u) {
    rlimit_as_ = PROTOBUF_ULONGLONG(4096);
    rlimit_cpu_ = PROTOBUF_ULONGLONG(600);
    rlimit_fsize_ = PROTOBUF_ULONGLONG(1);
    rlimit_nofile_ = PROTOBUF_ULONGLONG(32);
    rlimit_nproc_ = PROTOBUF_ULONGLONG(1024);
    rlimit_stack_ = PROTOBUF_ULONGLONG(8);
    rlimit_nproc_type_ = 1;
    rlimit_stack_type_ = 1;
  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x0000007fu) {
    clone_newnet_ = true;
    clone_newuser_ = true;
    clone_newns_ = true;
    clone_newpid_ = true;
    clone_newipc_ = true;
    clone_newuts_ = true;
    clone_newcgroup_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NsJailConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1 [default = ""];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_description();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.description");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .nsjail.Mode mode = 3 [default = ONCE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::nsjail::Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string hostname = 8 [default = "NSJAIL"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_hostname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.hostname");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cwd = 9 [default = "/"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_cwd();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cwd");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 port = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_port(&_has_bits_);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string bindhost = 11 [default = "::"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_bindhost();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.bindhost");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 max_conns_per_ip = 12 [default = 0];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_max_conns_per_ip(&_has_bits_);
          max_conns_per_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 time_limit = 13 [default = 600];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_time_limit(&_has_bits_);
          time_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool daemon = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_daemon(&_has_bits_);
          daemon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 max_cpus = 15 [default = 0];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_max_cpus(&_has_bits_);
          max_cpus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 log_fd = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_log_fd(&_has_bits_);
          log_fd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string log_file = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          auto str = _internal_mutable_log_file();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.log_file");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.LogLevel log_level = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::LogLevel_IsValid(val))) {
            _internal_set_log_level(static_cast<::nsjail::LogLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool keep_env = 19 [default = false];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_keep_env(&_has_bits_);
          keep_env_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string envar = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_envar();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.envar");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool keep_caps = 21 [default = false];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_keep_caps(&_has_bits_);
          keep_caps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string cap = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_cap();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cap");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool silent = 23 [default = false];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_silent(&_has_bits_);
          silent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool skip_setsid = 24 [default = false];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_skip_setsid(&_has_bits_);
          skip_setsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool stderr_to_null = 25 [default = false];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_stderr_to_null(&_has_bits_);
          stderr_to_null_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 pass_fd = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_pass_fd(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<208>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_pass_fd(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool disable_no_new_privs = 27 [default = false];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_disable_no_new_privs(&_has_bits_);
          disable_no_new_privs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 rlimit_as = 28 [default = 4096];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_rlimit_as(&_has_bits_);
          rlimit_as_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.RLimit rlimit_as_type = 29 [default = VALUE];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::RLimit_IsValid(val))) {
            _internal_set_rlimit_as_type(static_cast<::nsjail::RLimit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(29, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 rlimit_core = 30 [default = 0];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_rlimit_core(&_has_bits_);
          rlimit_core_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.RLimit rlimit_core_type = 31 [default = VALUE];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::RLimit_IsValid(val))) {
            _internal_set_rlimit_core_type(static_cast<::nsjail::RLimit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(31, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 rlimit_cpu = 32 [default = 600];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_rlimit_cpu(&_has_bits_);
          rlimit_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.RLimit rlimit_cpu_type = 33 [default = VALUE];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::RLimit_IsValid(val))) {
            _internal_set_rlimit_cpu_type(static_cast<::nsjail::RLimit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(33, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 rlimit_fsize = 34 [default = 1];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_rlimit_fsize(&_has_bits_);
          rlimit_fsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.RLimit rlimit_fsize_type = 35 [default = VALUE];
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::RLimit_IsValid(val))) {
            _internal_set_rlimit_fsize_type(static_cast<::nsjail::RLimit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(35, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 rlimit_nofile = 36 [default = 32];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_rlimit_nofile(&_has_bits_);
          rlimit_nofile_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.RLimit rlimit_nofile_type = 37 [default = VALUE];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::RLimit_IsValid(val))) {
            _internal_set_rlimit_nofile_type(static_cast<::nsjail::RLimit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(37, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 rlimit_nproc = 38 [default = 1024];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_rlimit_nproc(&_has_bits_);
          rlimit_nproc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.RLimit rlimit_nproc_type = 39 [default = SOFT];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::RLimit_IsValid(val))) {
            _internal_set_rlimit_nproc_type(static_cast<::nsjail::RLimit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(39, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 rlimit_stack = 40 [default = 8];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_rlimit_stack(&_has_bits_);
          rlimit_stack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.RLimit rlimit_stack_type = 41 [default = SOFT];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nsjail::RLimit_IsValid(val))) {
            _internal_set_rlimit_stack_type(static_cast<::nsjail::RLimit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(41, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool persona_addr_compat_layout = 42 [default = false];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_persona_addr_compat_layout(&_has_bits_);
          persona_addr_compat_layout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool persona_mmap_page_zero = 43 [default = false];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_persona_mmap_page_zero(&_has_bits_);
          persona_mmap_page_zero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool persona_read_implies_exec = 44 [default = false];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_persona_read_implies_exec(&_has_bits_);
          persona_read_implies_exec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool persona_addr_limit_3gb = 45 [default = false];
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_persona_addr_limit_3gb(&_has_bits_);
          persona_addr_limit_3gb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool persona_addr_no_randomize = 46 [default = false];
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_persona_addr_no_randomize(&_has_bits_);
          persona_addr_no_randomize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool clone_newnet = 47 [default = true];
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_clone_newnet(&_has_bits_);
          clone_newnet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool clone_newuser = 48 [default = true];
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_clone_newuser(&_has_bits_);
          clone_newuser_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool clone_newns = 49 [default = true];
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_clone_newns(&_has_bits_);
          clone_newns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool clone_newpid = 50 [default = true];
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_clone_newpid(&_has_bits_);
          clone_newpid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool clone_newipc = 51 [default = true];
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_clone_newipc(&_has_bits_);
          clone_newipc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool clone_newuts = 52 [default = true];
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_clone_newuts(&_has_bits_);
          clone_newuts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool clone_newcgroup = 53 [default = true];
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_clone_newcgroup(&_has_bits_);
          clone_newcgroup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .nsjail.IdMap uidmap = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_uidmap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<434>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .nsjail.IdMap gidmap = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_gidmap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<442>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool mount_proc = 56 [default = false];
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_mount_proc(&_has_bits_);
          mount_proc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .nsjail.MountPt mount = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_mount(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<458>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string seccomp_policy_file = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          auto str = _internal_mutable_seccomp_policy_file();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.seccomp_policy_file");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string seccomp_string = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_seccomp_string();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.seccomp_string");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<474>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool seccomp_log = 60 [default = false];
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_seccomp_log(&_has_bits_);
          seccomp_log_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 cgroup_mem_max = 61 [default = 0];
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_cgroup_mem_max(&_has_bits_);
          cgroup_mem_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_mem_mount = 62 [default = "/sys/fs/cgroup/memory"];
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          auto str = _internal_mutable_cgroup_mem_mount();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_mem_mount");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_mem_parent = 63 [default = "NSJAIL"];
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 250)) {
          auto str = _internal_mutable_cgroup_mem_parent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_mem_parent");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 cgroup_pids_max = 64 [default = 0];
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_cgroup_pids_max(&_has_bits_);
          cgroup_pids_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_pids_mount = 65 [default = "/sys/fs/cgroup/pids"];
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_cgroup_pids_mount();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_pids_mount");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_pids_parent = 66 [default = "NSJAIL"];
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_cgroup_pids_parent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_pids_parent");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cgroup_net_cls_classid = 67 [default = 0];
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_cgroup_net_cls_classid(&_has_bits_);
          cgroup_net_cls_classid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_net_cls_mount = 68 [default = "/sys/fs/cgroup/net_cls"];
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_cgroup_net_cls_mount();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_net_cls_mount");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_net_cls_parent = 69 [default = "NSJAIL"];
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_cgroup_net_cls_parent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_net_cls_parent");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cgroup_cpu_ms_per_sec = 70 [default = 0];
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_cgroup_cpu_ms_per_sec(&_has_bits_);
          cgroup_cpu_ms_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_cpu_mount = 71 [default = "/sys/fs/cgroup/cpu"];
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_cgroup_cpu_mount();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_cpu_mount");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroup_cpu_parent = 72 [default = "NSJAIL"];
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_cgroup_cpu_parent();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroup_cpu_parent");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string cgroupv2_mount = 73 [default = "/sys/fs/cgroup"];
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_cgroupv2_mount();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.cgroupv2_mount");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_cgroupv2 = 74 [default = false];
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_use_cgroupv2(&_has_bits_);
          use_cgroupv2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool iface_no_lo = 75 [default = false];
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_iface_no_lo(&_has_bits_);
          iface_no_lo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string iface_own = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_iface_own();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.iface_own");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<610>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string macvlan_iface = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_macvlan_iface();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.macvlan_iface");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string macvlan_vs_ip = 78 [default = "192.168.0.2"];
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          auto str = _internal_mutable_macvlan_vs_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.macvlan_vs_ip");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string macvlan_vs_nm = 79 [default = "255.255.255.0"];
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          auto str = _internal_mutable_macvlan_vs_nm();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.macvlan_vs_nm");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string macvlan_vs_gw = 80 [default = "192.168.0.1"];
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          auto str = _internal_mutable_macvlan_vs_gw();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.macvlan_vs_gw");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string macvlan_vs_ma = 81 [default = ""];
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          auto str = _internal_mutable_macvlan_vs_ma();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "nsjail.NsJailConfig.macvlan_vs_ma");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nice_level = 82 [default = 19];
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_nice_level(&_has_bits_);
          nice_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .nsjail.Exe exec_bin = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_exec_bin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool disable_rl = 84 [default = false];
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_disable_rl(&_has_bits_);
          disable_rl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NsJailConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsjail.NsJailConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1 [default = ""];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated string description = 2;
  for (int i = 0, n = this->_internal_description_size(); i < n; i++) {
    const auto& s = this->_internal_description(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.description");
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _has_bits_[1];
  // optional .nsjail.Mode mode = 3 [default = ONCE];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_mode(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string hostname = 8 [default = "NSJAIL"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.hostname");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_hostname(), target);
  }

  // optional string cwd = 9 [default = "/"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cwd().data(), static_cast<int>(this->_internal_cwd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cwd");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_cwd(), target);
  }

  // optional uint32 port = 10 [default = 0];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_port(), target);
  }

  // optional string bindhost = 11 [default = "::"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_bindhost().data(), static_cast<int>(this->_internal_bindhost().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.bindhost");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_bindhost(), target);
  }

  // optional uint32 max_conns_per_ip = 12 [default = 0];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_max_conns_per_ip(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 time_limit = 13 [default = 600];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_time_limit(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool daemon = 14 [default = false];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_daemon(), target);
  }

  // optional uint32 max_cpus = 15 [default = 0];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->_internal_max_cpus(), target);
  }

  // optional int32 log_fd = 16;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(16, this->_internal_log_fd(), target);
  }

  // optional string log_file = 17;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_log_file().data(), static_cast<int>(this->_internal_log_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.log_file");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_log_file(), target);
  }

  // optional .nsjail.LogLevel log_level = 18;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      18, this->_internal_log_level(), target);
  }

  // optional bool keep_env = 19 [default = false];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_keep_env(), target);
  }

  // repeated string envar = 20;
  for (int i = 0, n = this->_internal_envar_size(); i < n; i++) {
    const auto& s = this->_internal_envar(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.envar");
    target = stream->WriteString(20, s, target);
  }

  // optional bool keep_caps = 21 [default = false];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_keep_caps(), target);
  }

  // repeated string cap = 22;
  for (int i = 0, n = this->_internal_cap_size(); i < n; i++) {
    const auto& s = this->_internal_cap(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cap");
    target = stream->WriteString(22, s, target);
  }

  // optional bool silent = 23 [default = false];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_silent(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool skip_setsid = 24 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_skip_setsid(), target);
  }

  // optional bool stderr_to_null = 25 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(25, this->_internal_stderr_to_null(), target);
  }

  // repeated int32 pass_fd = 26;
  for (int i = 0, n = this->_internal_pass_fd_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(26, this->_internal_pass_fd(i), target);
  }

  // optional bool disable_no_new_privs = 27 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(27, this->_internal_disable_no_new_privs(), target);
  }

  // optional uint64 rlimit_as = 28 [default = 4096];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(28, this->_internal_rlimit_as(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .nsjail.RLimit rlimit_as_type = 29 [default = VALUE];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      29, this->_internal_rlimit_as_type(), target);
  }

  // optional uint64 rlimit_core = 30 [default = 0];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(30, this->_internal_rlimit_core(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional .nsjail.RLimit rlimit_core_type = 31 [default = VALUE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      31, this->_internal_rlimit_core_type(), target);
  }

  // optional uint64 rlimit_cpu = 32 [default = 600];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(32, this->_internal_rlimit_cpu(), target);
  }

  // optional .nsjail.RLimit rlimit_cpu_type = 33 [default = VALUE];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      33, this->_internal_rlimit_cpu_type(), target);
  }

  // optional uint64 rlimit_fsize = 34 [default = 1];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(34, this->_internal_rlimit_fsize(), target);
  }

  // optional .nsjail.RLimit rlimit_fsize_type = 35 [default = VALUE];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      35, this->_internal_rlimit_fsize_type(), target);
  }

  // optional uint64 rlimit_nofile = 36 [default = 32];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(36, this->_internal_rlimit_nofile(), target);
  }

  // optional .nsjail.RLimit rlimit_nofile_type = 37 [default = VALUE];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      37, this->_internal_rlimit_nofile_type(), target);
  }

  // optional uint64 rlimit_nproc = 38 [default = 1024];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(38, this->_internal_rlimit_nproc(), target);
  }

  // optional .nsjail.RLimit rlimit_nproc_type = 39 [default = SOFT];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      39, this->_internal_rlimit_nproc_type(), target);
  }

  // optional uint64 rlimit_stack = 40 [default = 8];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(40, this->_internal_rlimit_stack(), target);
  }

  // optional .nsjail.RLimit rlimit_stack_type = 41 [default = SOFT];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      41, this->_internal_rlimit_stack_type(), target);
  }

  // optional bool persona_addr_compat_layout = 42 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(42, this->_internal_persona_addr_compat_layout(), target);
  }

  // optional bool persona_mmap_page_zero = 43 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(43, this->_internal_persona_mmap_page_zero(), target);
  }

  // optional bool persona_read_implies_exec = 44 [default = false];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(44, this->_internal_persona_read_implies_exec(), target);
  }

  // optional bool persona_addr_limit_3gb = 45 [default = false];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(45, this->_internal_persona_addr_limit_3gb(), target);
  }

  // optional bool persona_addr_no_randomize = 46 [default = false];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(46, this->_internal_persona_addr_no_randomize(), target);
  }

  cached_has_bits = _has_bits_[2];
  // optional bool clone_newnet = 47 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(47, this->_internal_clone_newnet(), target);
  }

  // optional bool clone_newuser = 48 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(48, this->_internal_clone_newuser(), target);
  }

  // optional bool clone_newns = 49 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(49, this->_internal_clone_newns(), target);
  }

  // optional bool clone_newpid = 50 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(50, this->_internal_clone_newpid(), target);
  }

  // optional bool clone_newipc = 51 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(51, this->_internal_clone_newipc(), target);
  }

  // optional bool clone_newuts = 52 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(52, this->_internal_clone_newuts(), target);
  }

  // optional bool clone_newcgroup = 53 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(53, this->_internal_clone_newcgroup(), target);
  }

  // repeated .nsjail.IdMap uidmap = 54;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_uidmap_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(54, this->_internal_uidmap(i), target, stream);
  }

  // repeated .nsjail.IdMap gidmap = 55;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_gidmap_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(55, this->_internal_gidmap(i), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool mount_proc = 56 [default = false];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(56, this->_internal_mount_proc(), target);
  }

  // repeated .nsjail.MountPt mount = 57;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_mount_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(57, this->_internal_mount(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string seccomp_policy_file = 58;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_seccomp_policy_file().data(), static_cast<int>(this->_internal_seccomp_policy_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.seccomp_policy_file");
    target = stream->WriteStringMaybeAliased(
        58, this->_internal_seccomp_policy_file(), target);
  }

  // repeated string seccomp_string = 59;
  for (int i = 0, n = this->_internal_seccomp_string_size(); i < n; i++) {
    const auto& s = this->_internal_seccomp_string(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.seccomp_string");
    target = stream->WriteString(59, s, target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool seccomp_log = 60 [default = false];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(60, this->_internal_seccomp_log(), target);
  }

  // optional uint64 cgroup_mem_max = 61 [default = 0];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(61, this->_internal_cgroup_mem_max(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string cgroup_mem_mount = 62 [default = "/sys/fs/cgroup/memory"];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_mem_mount().data(), static_cast<int>(this->_internal_cgroup_mem_mount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_mem_mount");
    target = stream->WriteStringMaybeAliased(
        62, this->_internal_cgroup_mem_mount(), target);
  }

  // optional string cgroup_mem_parent = 63 [default = "NSJAIL"];
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_mem_parent().data(), static_cast<int>(this->_internal_cgroup_mem_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_mem_parent");
    target = stream->WriteStringMaybeAliased(
        63, this->_internal_cgroup_mem_parent(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint64 cgroup_pids_max = 64 [default = 0];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(64, this->_internal_cgroup_pids_max(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string cgroup_pids_mount = 65 [default = "/sys/fs/cgroup/pids"];
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_pids_mount().data(), static_cast<int>(this->_internal_cgroup_pids_mount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_pids_mount");
    target = stream->WriteStringMaybeAliased(
        65, this->_internal_cgroup_pids_mount(), target);
  }

  // optional string cgroup_pids_parent = 66 [default = "NSJAIL"];
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_pids_parent().data(), static_cast<int>(this->_internal_cgroup_pids_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_pids_parent");
    target = stream->WriteStringMaybeAliased(
        66, this->_internal_cgroup_pids_parent(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 cgroup_net_cls_classid = 67 [default = 0];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(67, this->_internal_cgroup_net_cls_classid(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string cgroup_net_cls_mount = 68 [default = "/sys/fs/cgroup/net_cls"];
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_net_cls_mount().data(), static_cast<int>(this->_internal_cgroup_net_cls_mount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_net_cls_mount");
    target = stream->WriteStringMaybeAliased(
        68, this->_internal_cgroup_net_cls_mount(), target);
  }

  // optional string cgroup_net_cls_parent = 69 [default = "NSJAIL"];
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_net_cls_parent().data(), static_cast<int>(this->_internal_cgroup_net_cls_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_net_cls_parent");
    target = stream->WriteStringMaybeAliased(
        69, this->_internal_cgroup_net_cls_parent(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 cgroup_cpu_ms_per_sec = 70 [default = 0];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(70, this->_internal_cgroup_cpu_ms_per_sec(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string cgroup_cpu_mount = 71 [default = "/sys/fs/cgroup/cpu"];
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_cpu_mount().data(), static_cast<int>(this->_internal_cgroup_cpu_mount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_cpu_mount");
    target = stream->WriteStringMaybeAliased(
        71, this->_internal_cgroup_cpu_mount(), target);
  }

  // optional string cgroup_cpu_parent = 72 [default = "NSJAIL"];
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroup_cpu_parent().data(), static_cast<int>(this->_internal_cgroup_cpu_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroup_cpu_parent");
    target = stream->WriteStringMaybeAliased(
        72, this->_internal_cgroup_cpu_parent(), target);
  }

  // optional string cgroupv2_mount = 73 [default = "/sys/fs/cgroup"];
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cgroupv2_mount().data(), static_cast<int>(this->_internal_cgroupv2_mount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.cgroupv2_mount");
    target = stream->WriteStringMaybeAliased(
        73, this->_internal_cgroupv2_mount(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool use_cgroupv2 = 74 [default = false];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(74, this->_internal_use_cgroupv2(), target);
  }

  // optional bool iface_no_lo = 75 [default = false];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(75, this->_internal_iface_no_lo(), target);
  }

  // repeated string iface_own = 76;
  for (int i = 0, n = this->_internal_iface_own_size(); i < n; i++) {
    const auto& s = this->_internal_iface_own(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.iface_own");
    target = stream->WriteString(76, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string macvlan_iface = 77;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_macvlan_iface().data(), static_cast<int>(this->_internal_macvlan_iface().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.macvlan_iface");
    target = stream->WriteStringMaybeAliased(
        77, this->_internal_macvlan_iface(), target);
  }

  // optional string macvlan_vs_ip = 78 [default = "192.168.0.2"];
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_macvlan_vs_ip().data(), static_cast<int>(this->_internal_macvlan_vs_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.macvlan_vs_ip");
    target = stream->WriteStringMaybeAliased(
        78, this->_internal_macvlan_vs_ip(), target);
  }

  // optional string macvlan_vs_nm = 79 [default = "255.255.255.0"];
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_macvlan_vs_nm().data(), static_cast<int>(this->_internal_macvlan_vs_nm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.macvlan_vs_nm");
    target = stream->WriteStringMaybeAliased(
        79, this->_internal_macvlan_vs_nm(), target);
  }

  // optional string macvlan_vs_gw = 80 [default = "192.168.0.1"];
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_macvlan_vs_gw().data(), static_cast<int>(this->_internal_macvlan_vs_gw().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.macvlan_vs_gw");
    target = stream->WriteStringMaybeAliased(
        80, this->_internal_macvlan_vs_gw(), target);
  }

  // optional string macvlan_vs_ma = 81 [default = ""];
  if (cached_has_bits & 0x00080000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_macvlan_vs_ma().data(), static_cast<int>(this->_internal_macvlan_vs_ma().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "nsjail.NsJailConfig.macvlan_vs_ma");
    target = stream->WriteStringMaybeAliased(
        81, this->_internal_macvlan_vs_ma(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 nice_level = 82 [default = 19];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(82, this->_internal_nice_level(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .nsjail.Exe exec_bin = 83;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        83, _Internal::exec_bin(this), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool disable_rl = 84 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(84, this->_internal_disable_rl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsjail.NsJailConfig)
  return target;
}

size_t NsJailConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nsjail.NsJailConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string description = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(description_.size());
  for (int i = 0, n = description_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      description_.Get(i));
  }

  // repeated string envar = 20;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(envar_.size());
  for (int i = 0, n = envar_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      envar_.Get(i));
  }

  // repeated string cap = 22;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(cap_.size());
  for (int i = 0, n = cap_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      cap_.Get(i));
  }

  // repeated int32 pass_fd = 26;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->pass_fd_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_pass_fd_size());
    total_size += data_size;
  }

  // repeated .nsjail.IdMap uidmap = 54;
  total_size += 2UL * this->_internal_uidmap_size();
  for (const auto& msg : this->uidmap_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .nsjail.IdMap gidmap = 55;
  total_size += 2UL * this->_internal_gidmap_size();
  for (const auto& msg : this->gidmap_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .nsjail.MountPt mount = 57;
  total_size += 2UL * this->_internal_mount_size();
  for (const auto& msg : this->mount_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string seccomp_string = 59;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(seccomp_string_.size());
  for (int i = 0, n = seccomp_string_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      seccomp_string_.Get(i));
  }

  // repeated string iface_own = 76;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(iface_own_.size());
  for (int i = 0, n = iface_own_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      iface_own_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1 [default = ""];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string hostname = 8 [default = "NSJAIL"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hostname());
    }

    // optional string cwd = 9 [default = "/"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cwd());
    }

    // optional string bindhost = 11 [default = "::"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bindhost());
    }

    // optional string log_file = 17;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_log_file());
    }

    // optional string seccomp_policy_file = 58;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_seccomp_policy_file());
    }

    // optional string cgroup_mem_mount = 62 [default = "/sys/fs/cgroup/memory"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_mem_mount());
    }

    // optional string cgroup_mem_parent = 63 [default = "NSJAIL"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_mem_parent());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string cgroup_pids_mount = 65 [default = "/sys/fs/cgroup/pids"];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_pids_mount());
    }

    // optional string cgroup_pids_parent = 66 [default = "NSJAIL"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_pids_parent());
    }

    // optional string cgroup_net_cls_mount = 68 [default = "/sys/fs/cgroup/net_cls"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_net_cls_mount());
    }

    // optional string cgroup_net_cls_parent = 69 [default = "NSJAIL"];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_net_cls_parent());
    }

    // optional string cgroup_cpu_mount = 71 [default = "/sys/fs/cgroup/cpu"];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_cpu_mount());
    }

    // optional string cgroup_cpu_parent = 72 [default = "NSJAIL"];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroup_cpu_parent());
    }

    // optional string cgroupv2_mount = 73 [default = "/sys/fs/cgroup"];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cgroupv2_mount());
    }

    // optional string macvlan_iface = 77;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_macvlan_iface());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional string macvlan_vs_ip = 78 [default = "192.168.0.2"];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_macvlan_vs_ip());
    }

    // optional string macvlan_vs_nm = 79 [default = "255.255.255.0"];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_macvlan_vs_nm());
    }

    // optional string macvlan_vs_gw = 80 [default = "192.168.0.1"];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_macvlan_vs_gw());
    }

    // optional string macvlan_vs_ma = 81 [default = ""];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_macvlan_vs_ma());
    }

    // optional .nsjail.Exe exec_bin = 83;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *exec_bin_);
    }

    // optional uint32 port = 10 [default = 0];
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_port());
    }

    // optional uint32 max_conns_per_ip = 12 [default = 0];
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_max_conns_per_ip());
    }

    // optional uint32 max_cpus = 15 [default = 0];
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_max_cpus());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 log_fd = 16;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_log_fd());
    }

    // optional .nsjail.LogLevel log_level = 18;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_log_level());
    }

    // optional bool daemon = 14 [default = false];
    if (cached_has_bits & 0x04000000u) {
      total_size += 1 + 1;
    }

    // optional bool keep_env = 19 [default = false];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool keep_caps = 21 [default = false];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool silent = 23 [default = false];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional uint64 rlimit_core = 30 [default = 0];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_rlimit_core());
    }

    // optional .nsjail.RLimit rlimit_as_type = 29 [default = VALUE];
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rlimit_as_type());
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .nsjail.RLimit rlimit_core_type = 31 [default = VALUE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rlimit_core_type());
    }

    // optional .nsjail.RLimit rlimit_cpu_type = 33 [default = VALUE];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rlimit_cpu_type());
    }

    // optional .nsjail.RLimit rlimit_fsize_type = 35 [default = VALUE];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rlimit_fsize_type());
    }

    // optional .nsjail.RLimit rlimit_nofile_type = 37 [default = VALUE];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rlimit_nofile_type());
    }

    // optional bool skip_setsid = 24 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool stderr_to_null = 25 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool disable_no_new_privs = 27 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional bool disable_rl = 84 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool persona_addr_compat_layout = 42 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool persona_mmap_page_zero = 43 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool persona_read_implies_exec = 44 [default = false];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool persona_addr_limit_3gb = 45 [default = false];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool persona_addr_no_randomize = 46 [default = false];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool mount_proc = 56 [default = false];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool seccomp_log = 60 [default = false];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool use_cgroupv2 = 74 [default = false];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint64 cgroup_mem_max = 61 [default = 0];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_cgroup_mem_max());
    }

    // optional uint64 cgroup_pids_max = 64 [default = 0];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_cgroup_pids_max());
    }

    // optional uint32 cgroup_net_cls_classid = 67 [default = 0];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_cgroup_net_cls_classid());
    }

    // optional uint32 cgroup_cpu_ms_per_sec = 70 [default = 0];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_cgroup_cpu_ms_per_sec());
    }

    // optional bool iface_no_lo = 75 [default = false];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional int32 nice_level = 82 [default = 19];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_nice_level());
    }

    // optional .nsjail.Mode mode = 3 [default = ONCE];
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
    }

    // optional uint32 time_limit = 13 [default = 600];
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_time_limit());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint64 rlimit_as = 28 [default = 4096];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_rlimit_as());
    }

    // optional uint64 rlimit_cpu = 32 [default = 600];
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_rlimit_cpu());
    }

    // optional uint64 rlimit_fsize = 34 [default = 1];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_rlimit_fsize());
    }

    // optional uint64 rlimit_nofile = 36 [default = 32];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_rlimit_nofile());
    }

    // optional uint64 rlimit_nproc = 38 [default = 1024];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_rlimit_nproc());
    }

    // optional uint64 rlimit_stack = 40 [default = 8];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_rlimit_stack());
    }

    // optional .nsjail.RLimit rlimit_nproc_type = 39 [default = SOFT];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rlimit_nproc_type());
    }

    // optional .nsjail.RLimit rlimit_stack_type = 41 [default = SOFT];
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_rlimit_stack_type());
    }

  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x0000007fu) {
    // optional bool clone_newnet = 47 [default = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool clone_newuser = 48 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional bool clone_newns = 49 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional bool clone_newpid = 50 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool clone_newipc = 51 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool clone_newuts = 52 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool clone_newcgroup = 53 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NsJailConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:nsjail.NsJailConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const NsJailConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NsJailConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:nsjail.NsJailConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:nsjail.NsJailConfig)
    MergeFrom(*source);
  }
}

void NsJailConfig::MergeFrom(const NsJailConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:nsjail.NsJailConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  description_.MergeFrom(from.description_);
  envar_.MergeFrom(from.envar_);
  cap_.MergeFrom(from.cap_);
  pass_fd_.MergeFrom(from.pass_fd_);
  uidmap_.MergeFrom(from.uidmap_);
  gidmap_.MergeFrom(from.gidmap_);
  mount_.MergeFrom(from.mount_);
  seccomp_string_.MergeFrom(from.seccomp_string_);
  iface_own_.MergeFrom(from.iface_own_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_cwd(from._internal_cwd());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_bindhost(from._internal_bindhost());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_log_file(from._internal_log_file());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_seccomp_policy_file(from._internal_seccomp_policy_file());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_cgroup_mem_mount(from._internal_cgroup_mem_mount());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_cgroup_mem_parent(from._internal_cgroup_mem_parent());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_cgroup_pids_mount(from._internal_cgroup_pids_mount());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_cgroup_pids_parent(from._internal_cgroup_pids_parent());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_set_cgroup_net_cls_mount(from._internal_cgroup_net_cls_mount());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_set_cgroup_net_cls_parent(from._internal_cgroup_net_cls_parent());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_set_cgroup_cpu_mount(from._internal_cgroup_cpu_mount());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_set_cgroup_cpu_parent(from._internal_cgroup_cpu_parent());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_set_cgroupv2_mount(from._internal_cgroupv2_mount());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_set_macvlan_iface(from._internal_macvlan_iface());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_set_macvlan_vs_ip(from._internal_macvlan_vs_ip());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_set_macvlan_vs_nm(from._internal_macvlan_vs_nm());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_set_macvlan_vs_gw(from._internal_macvlan_vs_gw());
    }
    if (cached_has_bits & 0x00080000u) {
      _internal_set_macvlan_vs_ma(from._internal_macvlan_vs_ma());
    }
    if (cached_has_bits & 0x00100000u) {
      _internal_mutable_exec_bin()->::nsjail::Exe::MergeFrom(from._internal_exec_bin());
    }
    if (cached_has_bits & 0x00200000u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00400000u) {
      max_conns_per_ip_ = from.max_conns_per_ip_;
    }
    if (cached_has_bits & 0x00800000u) {
      max_cpus_ = from.max_cpus_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      log_fd_ = from.log_fd_;
    }
    if (cached_has_bits & 0x02000000u) {
      log_level_ = from.log_level_;
    }
    if (cached_has_bits & 0x04000000u) {
      daemon_ = from.daemon_;
    }
    if (cached_has_bits & 0x08000000u) {
      keep_env_ = from.keep_env_;
    }
    if (cached_has_bits & 0x10000000u) {
      keep_caps_ = from.keep_caps_;
    }
    if (cached_has_bits & 0x20000000u) {
      silent_ = from.silent_;
    }
    if (cached_has_bits & 0x40000000u) {
      rlimit_core_ = from.rlimit_core_;
    }
    if (cached_has_bits & 0x80000000u) {
      rlimit_as_type_ = from.rlimit_as_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      rlimit_core_type_ = from.rlimit_core_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      rlimit_cpu_type_ = from.rlimit_cpu_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      rlimit_fsize_type_ = from.rlimit_fsize_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      rlimit_nofile_type_ = from.rlimit_nofile_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      skip_setsid_ = from.skip_setsid_;
    }
    if (cached_has_bits & 0x00000020u) {
      stderr_to_null_ = from.stderr_to_null_;
    }
    if (cached_has_bits & 0x00000040u) {
      disable_no_new_privs_ = from.disable_no_new_privs_;
    }
    if (cached_has_bits & 0x00000080u) {
      disable_rl_ = from.disable_rl_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      persona_addr_compat_layout_ = from.persona_addr_compat_layout_;
    }
    if (cached_has_bits & 0x00000200u) {
      persona_mmap_page_zero_ = from.persona_mmap_page_zero_;
    }
    if (cached_has_bits & 0x00000400u) {
      persona_read_implies_exec_ = from.persona_read_implies_exec_;
    }
    if (cached_has_bits & 0x00000800u) {
      persona_addr_limit_3gb_ = from.persona_addr_limit_3gb_;
    }
    if (cached_has_bits & 0x00001000u) {
      persona_addr_no_randomize_ = from.persona_addr_no_randomize_;
    }
    if (cached_has_bits & 0x00002000u) {
      mount_proc_ = from.mount_proc_;
    }
    if (cached_has_bits & 0x00004000u) {
      seccomp_log_ = from.seccomp_log_;
    }
    if (cached_has_bits & 0x00008000u) {
      use_cgroupv2_ = from.use_cgroupv2_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      cgroup_mem_max_ = from.cgroup_mem_max_;
    }
    if (cached_has_bits & 0x00020000u) {
      cgroup_pids_max_ = from.cgroup_pids_max_;
    }
    if (cached_has_bits & 0x00040000u) {
      cgroup_net_cls_classid_ = from.cgroup_net_cls_classid_;
    }
    if (cached_has_bits & 0x00080000u) {
      cgroup_cpu_ms_per_sec_ = from.cgroup_cpu_ms_per_sec_;
    }
    if (cached_has_bits & 0x00100000u) {
      iface_no_lo_ = from.iface_no_lo_;
    }
    if (cached_has_bits & 0x00200000u) {
      nice_level_ = from.nice_level_;
    }
    if (cached_has_bits & 0x00400000u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00800000u) {
      time_limit_ = from.time_limit_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      rlimit_as_ = from.rlimit_as_;
    }
    if (cached_has_bits & 0x02000000u) {
      rlimit_cpu_ = from.rlimit_cpu_;
    }
    if (cached_has_bits & 0x04000000u) {
      rlimit_fsize_ = from.rlimit_fsize_;
    }
    if (cached_has_bits & 0x08000000u) {
      rlimit_nofile_ = from.rlimit_nofile_;
    }
    if (cached_has_bits & 0x10000000u) {
      rlimit_nproc_ = from.rlimit_nproc_;
    }
    if (cached_has_bits & 0x20000000u) {
      rlimit_stack_ = from.rlimit_stack_;
    }
    if (cached_has_bits & 0x40000000u) {
      rlimit_nproc_type_ = from.rlimit_nproc_type_;
    }
    if (cached_has_bits & 0x80000000u) {
      rlimit_stack_type_ = from.rlimit_stack_type_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[2];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      clone_newnet_ = from.clone_newnet_;
    }
    if (cached_has_bits & 0x00000002u) {
      clone_newuser_ = from.clone_newuser_;
    }
    if (cached_has_bits & 0x00000004u) {
      clone_newns_ = from.clone_newns_;
    }
    if (cached_has_bits & 0x00000008u) {
      clone_newpid_ = from.clone_newpid_;
    }
    if (cached_has_bits & 0x00000010u) {
      clone_newipc_ = from.clone_newipc_;
    }
    if (cached_has_bits & 0x00000020u) {
      clone_newuts_ = from.clone_newuts_;
    }
    if (cached_has_bits & 0x00000040u) {
      clone_newcgroup_ = from.clone_newcgroup_;
    }
    _has_bits_[2] |= cached_has_bits;
  }
}

void NsJailConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:nsjail.NsJailConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NsJailConfig::CopyFrom(const NsJailConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nsjail.NsJailConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NsJailConfig::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(mount_)) return false;
  if (_internal_has_exec_bin()) {
    if (!exec_bin_->IsInitialized()) return false;
  }
  return true;
}

void NsJailConfig::InternalSwap(NsJailConfig* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  swap(_has_bits_[2], other->_has_bits_[2]);
  description_.InternalSwap(&other->description_);
  envar_.InternalSwap(&other->envar_);
  cap_.InternalSwap(&other->cap_);
  pass_fd_.InternalSwap(&other->pass_fd_);
  uidmap_.InternalSwap(&other->uidmap_);
  gidmap_.InternalSwap(&other->gidmap_);
  mount_.InternalSwap(&other->mount_);
  seccomp_string_.InternalSwap(&other->seccomp_string_);
  iface_own_.InternalSwap(&other->iface_own_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  hostname_.Swap(&other->hostname_, nullptr, GetArena());
  cwd_.Swap(&other->cwd_, nullptr, GetArena());
  bindhost_.Swap(&other->bindhost_, nullptr, GetArena());
  log_file_.Swap(&other->log_file_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  seccomp_policy_file_.Swap(&other->seccomp_policy_file_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  cgroup_mem_mount_.Swap(&other->cgroup_mem_mount_, nullptr, GetArena());
  cgroup_mem_parent_.Swap(&other->cgroup_mem_parent_, nullptr, GetArena());
  cgroup_pids_mount_.Swap(&other->cgroup_pids_mount_, nullptr, GetArena());
  cgroup_pids_parent_.Swap(&other->cgroup_pids_parent_, nullptr, GetArena());
  cgroup_net_cls_mount_.Swap(&other->cgroup_net_cls_mount_, nullptr, GetArena());
  cgroup_net_cls_parent_.Swap(&other->cgroup_net_cls_parent_, nullptr, GetArena());
  cgroup_cpu_mount_.Swap(&other->cgroup_cpu_mount_, nullptr, GetArena());
  cgroup_cpu_parent_.Swap(&other->cgroup_cpu_parent_, nullptr, GetArena());
  cgroupv2_mount_.Swap(&other->cgroupv2_mount_, nullptr, GetArena());
  macvlan_iface_.Swap(&other->macvlan_iface_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  macvlan_vs_ip_.Swap(&other->macvlan_vs_ip_, nullptr, GetArena());
  macvlan_vs_nm_.Swap(&other->macvlan_vs_nm_, nullptr, GetArena());
  macvlan_vs_gw_.Swap(&other->macvlan_vs_gw_, nullptr, GetArena());
  macvlan_vs_ma_.Swap(&other->macvlan_vs_ma_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NsJailConfig, iface_no_lo_)
      + sizeof(NsJailConfig::iface_no_lo_)
      - PROTOBUF_FIELD_OFFSET(NsJailConfig, exec_bin_)>(
          reinterpret_cast<char*>(&exec_bin_),
          reinterpret_cast<char*>(&other->exec_bin_));
  swap(nice_level_, other->nice_level_);
  swap(mode_, other->mode_);
  swap(time_limit_, other->time_limit_);
  swap(rlimit_as_, other->rlimit_as_);
  swap(rlimit_cpu_, other->rlimit_cpu_);
  swap(rlimit_fsize_, other->rlimit_fsize_);
  swap(rlimit_nofile_, other->rlimit_nofile_);
  swap(rlimit_nproc_, other->rlimit_nproc_);
  swap(rlimit_stack_, other->rlimit_stack_);
  swap(rlimit_nproc_type_, other->rlimit_nproc_type_);
  swap(rlimit_stack_type_, other->rlimit_stack_type_);
  swap(clone_newnet_, other->clone_newnet_);
  swap(clone_newuser_, other->clone_newuser_);
  swap(clone_newns_, other->clone_newns_);
  swap(clone_newpid_, other->clone_newpid_);
  swap(clone_newipc_, other->clone_newipc_);
  swap(clone_newuts_, other->clone_newuts_);
  swap(clone_newcgroup_, other->clone_newcgroup_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NsJailConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace nsjail
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::nsjail::IdMap* Arena::CreateMaybeMessage< ::nsjail::IdMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nsjail::IdMap >(arena);
}
template<> PROTOBUF_NOINLINE ::nsjail::MountPt* Arena::CreateMaybeMessage< ::nsjail::MountPt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nsjail::MountPt >(arena);
}
template<> PROTOBUF_NOINLINE ::nsjail::Exe* Arena::CreateMaybeMessage< ::nsjail::Exe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nsjail::Exe >(arena);
}
template<> PROTOBUF_NOINLINE ::nsjail::NsJailConfig* Arena::CreateMaybeMessage< ::nsjail::NsJailConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nsjail::NsJailConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
