// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_config_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_config_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_config_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_config_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_config_2eproto;
namespace nsjail {
class Exe;
class ExeDefaultTypeInternal;
extern ExeDefaultTypeInternal _Exe_default_instance_;
class IdMap;
class IdMapDefaultTypeInternal;
extern IdMapDefaultTypeInternal _IdMap_default_instance_;
class MountPt;
class MountPtDefaultTypeInternal;
extern MountPtDefaultTypeInternal _MountPt_default_instance_;
class NsJailConfig;
class NsJailConfigDefaultTypeInternal;
extern NsJailConfigDefaultTypeInternal _NsJailConfig_default_instance_;
}  // namespace nsjail
PROTOBUF_NAMESPACE_OPEN
template<> ::nsjail::Exe* Arena::CreateMaybeMessage<::nsjail::Exe>(Arena*);
template<> ::nsjail::IdMap* Arena::CreateMaybeMessage<::nsjail::IdMap>(Arena*);
template<> ::nsjail::MountPt* Arena::CreateMaybeMessage<::nsjail::MountPt>(Arena*);
template<> ::nsjail::NsJailConfig* Arena::CreateMaybeMessage<::nsjail::NsJailConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace nsjail {

enum Mode : int {
  LISTEN = 0,
  ONCE = 1,
  RERUN = 2,
  EXECVE = 3
};
bool Mode_IsValid(int value);
constexpr Mode Mode_MIN = LISTEN;
constexpr Mode Mode_MAX = EXECVE;
constexpr int Mode_ARRAYSIZE = Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Mode_descriptor();
template<typename T>
inline const std::string& Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Mode_descriptor(), enum_t_value);
}
inline bool Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Mode>(
    Mode_descriptor(), name, value);
}
enum LogLevel : int {
  DEBUG = 0,
  INFO = 1,
  WARNING = 2,
  ERROR = 3,
  FATAL = 4
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = DEBUG;
constexpr LogLevel LogLevel_MAX = FATAL;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum RLimit : int {
  VALUE = 0,
  SOFT = 1,
  HARD = 2,
  INF = 3
};
bool RLimit_IsValid(int value);
constexpr RLimit RLimit_MIN = VALUE;
constexpr RLimit RLimit_MAX = INF;
constexpr int RLimit_ARRAYSIZE = RLimit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RLimit_descriptor();
template<typename T>
inline const std::string& RLimit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RLimit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RLimit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RLimit_descriptor(), enum_t_value);
}
inline bool RLimit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RLimit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RLimit>(
    RLimit_descriptor(), name, value);
}
// ===================================================================

class IdMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nsjail.IdMap) */ {
 public:
  inline IdMap() : IdMap(nullptr) {}
  virtual ~IdMap();

  IdMap(const IdMap& from);
  IdMap(IdMap&& from) noexcept
    : IdMap() {
    *this = ::std::move(from);
  }

  inline IdMap& operator=(const IdMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdMap& operator=(IdMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IdMap& default_instance();

  static inline const IdMap* internal_default_instance() {
    return reinterpret_cast<const IdMap*>(
               &_IdMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IdMap& a, IdMap& b) {
    a.Swap(&b);
  }
  inline void Swap(IdMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IdMap* New() const final {
    return CreateMaybeMessage<IdMap>(nullptr);
  }

  IdMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IdMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IdMap& from);
  void MergeFrom(const IdMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nsjail.IdMap";
  }
  protected:
  explicit IdMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsideIdFieldNumber = 1,
    kOutsideIdFieldNumber = 2,
    kUseNewidmapFieldNumber = 4,
    kCountFieldNumber = 3,
  };
  // optional string inside_id = 1 [default = ""];
  bool has_inside_id() const;
  private:
  bool _internal_has_inside_id() const;
  public:
  void clear_inside_id();
  const std::string& inside_id() const;
  void set_inside_id(const std::string& value);
  void set_inside_id(std::string&& value);
  void set_inside_id(const char* value);
  void set_inside_id(const char* value, size_t size);
  std::string* mutable_inside_id();
  std::string* release_inside_id();
  void set_allocated_inside_id(std::string* inside_id);
  private:
  const std::string& _internal_inside_id() const;
  void _internal_set_inside_id(const std::string& value);
  std::string* _internal_mutable_inside_id();
  public:

  // optional string outside_id = 2 [default = ""];
  bool has_outside_id() const;
  private:
  bool _internal_has_outside_id() const;
  public:
  void clear_outside_id();
  const std::string& outside_id() const;
  void set_outside_id(const std::string& value);
  void set_outside_id(std::string&& value);
  void set_outside_id(const char* value);
  void set_outside_id(const char* value, size_t size);
  std::string* mutable_outside_id();
  std::string* release_outside_id();
  void set_allocated_outside_id(std::string* outside_id);
  private:
  const std::string& _internal_outside_id() const;
  void _internal_set_outside_id(const std::string& value);
  std::string* _internal_mutable_outside_id();
  public:

  // optional bool use_newidmap = 4 [default = false];
  bool has_use_newidmap() const;
  private:
  bool _internal_has_use_newidmap() const;
  public:
  void clear_use_newidmap();
  bool use_newidmap() const;
  void set_use_newidmap(bool value);
  private:
  bool _internal_use_newidmap() const;
  void _internal_set_use_newidmap(bool value);
  public:

  // optional uint32 count = 3 [default = 1];
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:nsjail.IdMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inside_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr outside_id_;
  bool use_newidmap_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class MountPt PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nsjail.MountPt) */ {
 public:
  inline MountPt() : MountPt(nullptr) {}
  virtual ~MountPt();

  MountPt(const MountPt& from);
  MountPt(MountPt&& from) noexcept
    : MountPt() {
    *this = ::std::move(from);
  }

  inline MountPt& operator=(const MountPt& from) {
    CopyFrom(from);
    return *this;
  }
  inline MountPt& operator=(MountPt&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MountPt& default_instance();

  static inline const MountPt* internal_default_instance() {
    return reinterpret_cast<const MountPt*>(
               &_MountPt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MountPt& a, MountPt& b) {
    a.Swap(&b);
  }
  inline void Swap(MountPt* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MountPt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MountPt* New() const final {
    return CreateMaybeMessage<MountPt>(nullptr);
  }

  MountPt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MountPt>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MountPt& from);
  void MergeFrom(const MountPt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MountPt* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nsjail.MountPt";
  }
  protected:
  explicit MountPt(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kPrefixSrcEnvFieldNumber = 2,
    kSrcContentFieldNumber = 3,
    kDstFieldNumber = 4,
    kPrefixDstEnvFieldNumber = 5,
    kFstypeFieldNumber = 6,
    kOptionsFieldNumber = 7,
    kIsBindFieldNumber = 8,
    kRwFieldNumber = 9,
    kIsDirFieldNumber = 10,
    kIsSymlinkFieldNumber = 12,
    kNosuidFieldNumber = 13,
    kNodevFieldNumber = 14,
    kNoexecFieldNumber = 15,
    kMandatoryFieldNumber = 11,
  };
  // optional string src = 1 [default = ""];
  bool has_src() const;
  private:
  bool _internal_has_src() const;
  public:
  void clear_src();
  const std::string& src() const;
  void set_src(const std::string& value);
  void set_src(std::string&& value);
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  std::string* mutable_src();
  std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // optional string prefix_src_env = 2 [default = ""];
  bool has_prefix_src_env() const;
  private:
  bool _internal_has_prefix_src_env() const;
  public:
  void clear_prefix_src_env();
  const std::string& prefix_src_env() const;
  void set_prefix_src_env(const std::string& value);
  void set_prefix_src_env(std::string&& value);
  void set_prefix_src_env(const char* value);
  void set_prefix_src_env(const char* value, size_t size);
  std::string* mutable_prefix_src_env();
  std::string* release_prefix_src_env();
  void set_allocated_prefix_src_env(std::string* prefix_src_env);
  private:
  const std::string& _internal_prefix_src_env() const;
  void _internal_set_prefix_src_env(const std::string& value);
  std::string* _internal_mutable_prefix_src_env();
  public:

  // optional bytes src_content = 3 [default = ""];
  bool has_src_content() const;
  private:
  bool _internal_has_src_content() const;
  public:
  void clear_src_content();
  const std::string& src_content() const;
  void set_src_content(const std::string& value);
  void set_src_content(std::string&& value);
  void set_src_content(const char* value);
  void set_src_content(const void* value, size_t size);
  std::string* mutable_src_content();
  std::string* release_src_content();
  void set_allocated_src_content(std::string* src_content);
  private:
  const std::string& _internal_src_content() const;
  void _internal_set_src_content(const std::string& value);
  std::string* _internal_mutable_src_content();
  public:

  // required string dst = 4 [default = ""];
  bool has_dst() const;
  private:
  bool _internal_has_dst() const;
  public:
  void clear_dst();
  const std::string& dst() const;
  void set_dst(const std::string& value);
  void set_dst(std::string&& value);
  void set_dst(const char* value);
  void set_dst(const char* value, size_t size);
  std::string* mutable_dst();
  std::string* release_dst();
  void set_allocated_dst(std::string* dst);
  private:
  const std::string& _internal_dst() const;
  void _internal_set_dst(const std::string& value);
  std::string* _internal_mutable_dst();
  public:

  // optional string prefix_dst_env = 5 [default = ""];
  bool has_prefix_dst_env() const;
  private:
  bool _internal_has_prefix_dst_env() const;
  public:
  void clear_prefix_dst_env();
  const std::string& prefix_dst_env() const;
  void set_prefix_dst_env(const std::string& value);
  void set_prefix_dst_env(std::string&& value);
  void set_prefix_dst_env(const char* value);
  void set_prefix_dst_env(const char* value, size_t size);
  std::string* mutable_prefix_dst_env();
  std::string* release_prefix_dst_env();
  void set_allocated_prefix_dst_env(std::string* prefix_dst_env);
  private:
  const std::string& _internal_prefix_dst_env() const;
  void _internal_set_prefix_dst_env(const std::string& value);
  std::string* _internal_mutable_prefix_dst_env();
  public:

  // optional string fstype = 6 [default = ""];
  bool has_fstype() const;
  private:
  bool _internal_has_fstype() const;
  public:
  void clear_fstype();
  const std::string& fstype() const;
  void set_fstype(const std::string& value);
  void set_fstype(std::string&& value);
  void set_fstype(const char* value);
  void set_fstype(const char* value, size_t size);
  std::string* mutable_fstype();
  std::string* release_fstype();
  void set_allocated_fstype(std::string* fstype);
  private:
  const std::string& _internal_fstype() const;
  void _internal_set_fstype(const std::string& value);
  std::string* _internal_mutable_fstype();
  public:

  // optional string options = 7 [default = ""];
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const std::string& options() const;
  void set_options(const std::string& value);
  void set_options(std::string&& value);
  void set_options(const char* value);
  void set_options(const char* value, size_t size);
  std::string* mutable_options();
  std::string* release_options();
  void set_allocated_options(std::string* options);
  private:
  const std::string& _internal_options() const;
  void _internal_set_options(const std::string& value);
  std::string* _internal_mutable_options();
  public:

  // optional bool is_bind = 8 [default = false];
  bool has_is_bind() const;
  private:
  bool _internal_has_is_bind() const;
  public:
  void clear_is_bind();
  bool is_bind() const;
  void set_is_bind(bool value);
  private:
  bool _internal_is_bind() const;
  void _internal_set_is_bind(bool value);
  public:

  // optional bool rw = 9 [default = false];
  bool has_rw() const;
  private:
  bool _internal_has_rw() const;
  public:
  void clear_rw();
  bool rw() const;
  void set_rw(bool value);
  private:
  bool _internal_rw() const;
  void _internal_set_rw(bool value);
  public:

  // optional bool is_dir = 10;
  bool has_is_dir() const;
  private:
  bool _internal_has_is_dir() const;
  public:
  void clear_is_dir();
  bool is_dir() const;
  void set_is_dir(bool value);
  private:
  bool _internal_is_dir() const;
  void _internal_set_is_dir(bool value);
  public:

  // optional bool is_symlink = 12 [default = false];
  bool has_is_symlink() const;
  private:
  bool _internal_has_is_symlink() const;
  public:
  void clear_is_symlink();
  bool is_symlink() const;
  void set_is_symlink(bool value);
  private:
  bool _internal_is_symlink() const;
  void _internal_set_is_symlink(bool value);
  public:

  // optional bool nosuid = 13 [default = false];
  bool has_nosuid() const;
  private:
  bool _internal_has_nosuid() const;
  public:
  void clear_nosuid();
  bool nosuid() const;
  void set_nosuid(bool value);
  private:
  bool _internal_nosuid() const;
  void _internal_set_nosuid(bool value);
  public:

  // optional bool nodev = 14 [default = false];
  bool has_nodev() const;
  private:
  bool _internal_has_nodev() const;
  public:
  void clear_nodev();
  bool nodev() const;
  void set_nodev(bool value);
  private:
  bool _internal_nodev() const;
  void _internal_set_nodev(bool value);
  public:

  // optional bool noexec = 15 [default = false];
  bool has_noexec() const;
  private:
  bool _internal_has_noexec() const;
  public:
  void clear_noexec();
  bool noexec() const;
  void set_noexec(bool value);
  private:
  bool _internal_noexec() const;
  void _internal_set_noexec(bool value);
  public:

  // optional bool mandatory = 11 [default = true];
  bool has_mandatory() const;
  private:
  bool _internal_has_mandatory() const;
  public:
  void clear_mandatory();
  bool mandatory() const;
  void set_mandatory(bool value);
  private:
  bool _internal_mandatory() const;
  void _internal_set_mandatory(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nsjail.MountPt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_src_env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_dst_env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fstype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr options_;
  bool is_bind_;
  bool rw_;
  bool is_dir_;
  bool is_symlink_;
  bool nosuid_;
  bool nodev_;
  bool noexec_;
  bool mandatory_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class Exe PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nsjail.Exe) */ {
 public:
  inline Exe() : Exe(nullptr) {}
  virtual ~Exe();

  Exe(const Exe& from);
  Exe(Exe&& from) noexcept
    : Exe() {
    *this = ::std::move(from);
  }

  inline Exe& operator=(const Exe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Exe& operator=(Exe&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Exe& default_instance();

  static inline const Exe* internal_default_instance() {
    return reinterpret_cast<const Exe*>(
               &_Exe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Exe& a, Exe& b) {
    a.Swap(&b);
  }
  inline void Swap(Exe* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Exe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Exe* New() const final {
    return CreateMaybeMessage<Exe>(nullptr);
  }

  Exe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Exe>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Exe& from);
  void MergeFrom(const Exe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exe* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nsjail.Exe";
  }
  protected:
  explicit Exe(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgFieldNumber = 2,
    kPathFieldNumber = 1,
    kArg0FieldNumber = 3,
    kExecFdFieldNumber = 4,
  };
  // repeated string arg = 2;
  int arg_size() const;
  private:
  int _internal_arg_size() const;
  public:
  void clear_arg();
  const std::string& arg(int index) const;
  std::string* mutable_arg(int index);
  void set_arg(int index, const std::string& value);
  void set_arg(int index, std::string&& value);
  void set_arg(int index, const char* value);
  void set_arg(int index, const char* value, size_t size);
  std::string* add_arg();
  void add_arg(const std::string& value);
  void add_arg(std::string&& value);
  void add_arg(const char* value);
  void add_arg(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arg();
  private:
  const std::string& _internal_arg(int index) const;
  std::string* _internal_add_arg();
  public:

  // required string path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string arg0 = 3;
  bool has_arg0() const;
  private:
  bool _internal_has_arg0() const;
  public:
  void clear_arg0();
  const std::string& arg0() const;
  void set_arg0(const std::string& value);
  void set_arg0(std::string&& value);
  void set_arg0(const char* value);
  void set_arg0(const char* value, size_t size);
  std::string* mutable_arg0();
  std::string* release_arg0();
  void set_allocated_arg0(std::string* arg0);
  private:
  const std::string& _internal_arg0() const;
  void _internal_set_arg0(const std::string& value);
  std::string* _internal_mutable_arg0();
  public:

  // optional bool exec_fd = 4 [default = false];
  bool has_exec_fd() const;
  private:
  bool _internal_has_exec_fd() const;
  public:
  void clear_exec_fd();
  bool exec_fd() const;
  void set_exec_fd(bool value);
  private:
  bool _internal_exec_fd() const;
  void _internal_set_exec_fd(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nsjail.Exe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg0_;
  bool exec_fd_;
  friend struct ::TableStruct_config_2eproto;
};
// -------------------------------------------------------------------

class NsJailConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nsjail.NsJailConfig) */ {
 public:
  inline NsJailConfig() : NsJailConfig(nullptr) {}
  virtual ~NsJailConfig();

  NsJailConfig(const NsJailConfig& from);
  NsJailConfig(NsJailConfig&& from) noexcept
    : NsJailConfig() {
    *this = ::std::move(from);
  }

  inline NsJailConfig& operator=(const NsJailConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NsJailConfig& operator=(NsJailConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NsJailConfig& default_instance();

  static inline const NsJailConfig* internal_default_instance() {
    return reinterpret_cast<const NsJailConfig*>(
               &_NsJailConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NsJailConfig& a, NsJailConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NsJailConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NsJailConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NsJailConfig* New() const final {
    return CreateMaybeMessage<NsJailConfig>(nullptr);
  }

  NsJailConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NsJailConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NsJailConfig& from);
  void MergeFrom(const NsJailConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NsJailConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nsjail.NsJailConfig";
  }
  protected:
  explicit NsJailConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_config_2eproto);
    return ::descriptor_table_config_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kEnvarFieldNumber = 20,
    kCapFieldNumber = 22,
    kPassFdFieldNumber = 26,
    kUidmapFieldNumber = 54,
    kGidmapFieldNumber = 55,
    kMountFieldNumber = 57,
    kSeccompStringFieldNumber = 59,
    kIfaceOwnFieldNumber = 76,
    kNameFieldNumber = 1,
    kHostnameFieldNumber = 8,
    kCwdFieldNumber = 9,
    kBindhostFieldNumber = 11,
    kLogFileFieldNumber = 17,
    kSeccompPolicyFileFieldNumber = 58,
    kCgroupMemMountFieldNumber = 62,
    kCgroupMemParentFieldNumber = 63,
    kCgroupPidsMountFieldNumber = 65,
    kCgroupPidsParentFieldNumber = 66,
    kCgroupNetClsMountFieldNumber = 68,
    kCgroupNetClsParentFieldNumber = 69,
    kCgroupCpuMountFieldNumber = 71,
    kCgroupCpuParentFieldNumber = 72,
    kCgroupv2MountFieldNumber = 73,
    kMacvlanIfaceFieldNumber = 77,
    kMacvlanVsIpFieldNumber = 78,
    kMacvlanVsNmFieldNumber = 79,
    kMacvlanVsGwFieldNumber = 80,
    kMacvlanVsMaFieldNumber = 81,
    kExecBinFieldNumber = 83,
    kPortFieldNumber = 10,
    kMaxConnsPerIpFieldNumber = 12,
    kMaxCpusFieldNumber = 15,
    kLogFdFieldNumber = 16,
    kLogLevelFieldNumber = 18,
    kDaemonFieldNumber = 14,
    kKeepEnvFieldNumber = 19,
    kKeepCapsFieldNumber = 21,
    kSilentFieldNumber = 23,
    kRlimitCoreFieldNumber = 30,
    kRlimitAsTypeFieldNumber = 29,
    kRlimitCoreTypeFieldNumber = 31,
    kRlimitCpuTypeFieldNumber = 33,
    kRlimitFsizeTypeFieldNumber = 35,
    kRlimitNofileTypeFieldNumber = 37,
    kSkipSetsidFieldNumber = 24,
    kStderrToNullFieldNumber = 25,
    kDisableNoNewPrivsFieldNumber = 27,
    kDisableRlFieldNumber = 84,
    kPersonaAddrCompatLayoutFieldNumber = 42,
    kPersonaMmapPageZeroFieldNumber = 43,
    kPersonaReadImpliesExecFieldNumber = 44,
    kPersonaAddrLimit3GbFieldNumber = 45,
    kPersonaAddrNoRandomizeFieldNumber = 46,
    kMountProcFieldNumber = 56,
    kSeccompLogFieldNumber = 60,
    kUseCgroupv2FieldNumber = 74,
    kCgroupMemMaxFieldNumber = 61,
    kCgroupPidsMaxFieldNumber = 64,
    kCgroupNetClsClassidFieldNumber = 67,
    kCgroupCpuMsPerSecFieldNumber = 70,
    kIfaceNoLoFieldNumber = 75,
    kNiceLevelFieldNumber = 82,
    kModeFieldNumber = 3,
    kTimeLimitFieldNumber = 13,
    kRlimitAsFieldNumber = 28,
    kRlimitCpuFieldNumber = 32,
    kRlimitFsizeFieldNumber = 34,
    kRlimitNofileFieldNumber = 36,
    kRlimitNprocFieldNumber = 38,
    kRlimitStackFieldNumber = 40,
    kRlimitNprocTypeFieldNumber = 39,
    kRlimitStackTypeFieldNumber = 41,
    kCloneNewnetFieldNumber = 47,
    kCloneNewuserFieldNumber = 48,
    kCloneNewnsFieldNumber = 49,
    kCloneNewpidFieldNumber = 50,
    kCloneNewipcFieldNumber = 51,
    kCloneNewutsFieldNumber = 52,
    kCloneNewcgroupFieldNumber = 53,
  };
  // repeated string description = 2;
  int description_size() const;
  private:
  int _internal_description_size() const;
  public:
  void clear_description();
  const std::string& description(int index) const;
  std::string* mutable_description(int index);
  void set_description(int index, const std::string& value);
  void set_description(int index, std::string&& value);
  void set_description(int index, const char* value);
  void set_description(int index, const char* value, size_t size);
  std::string* add_description();
  void add_description(const std::string& value);
  void add_description(std::string&& value);
  void add_description(const char* value);
  void add_description(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& description() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_description();
  private:
  const std::string& _internal_description(int index) const;
  std::string* _internal_add_description();
  public:

  // repeated string envar = 20;
  int envar_size() const;
  private:
  int _internal_envar_size() const;
  public:
  void clear_envar();
  const std::string& envar(int index) const;
  std::string* mutable_envar(int index);
  void set_envar(int index, const std::string& value);
  void set_envar(int index, std::string&& value);
  void set_envar(int index, const char* value);
  void set_envar(int index, const char* value, size_t size);
  std::string* add_envar();
  void add_envar(const std::string& value);
  void add_envar(std::string&& value);
  void add_envar(const char* value);
  void add_envar(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& envar() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_envar();
  private:
  const std::string& _internal_envar(int index) const;
  std::string* _internal_add_envar();
  public:

  // repeated string cap = 22;
  int cap_size() const;
  private:
  int _internal_cap_size() const;
  public:
  void clear_cap();
  const std::string& cap(int index) const;
  std::string* mutable_cap(int index);
  void set_cap(int index, const std::string& value);
  void set_cap(int index, std::string&& value);
  void set_cap(int index, const char* value);
  void set_cap(int index, const char* value, size_t size);
  std::string* add_cap();
  void add_cap(const std::string& value);
  void add_cap(std::string&& value);
  void add_cap(const char* value);
  void add_cap(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cap();
  private:
  const std::string& _internal_cap(int index) const;
  std::string* _internal_add_cap();
  public:

  // repeated int32 pass_fd = 26;
  int pass_fd_size() const;
  private:
  int _internal_pass_fd_size() const;
  public:
  void clear_pass_fd();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pass_fd(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_pass_fd() const;
  void _internal_add_pass_fd(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_pass_fd();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 pass_fd(int index) const;
  void set_pass_fd(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_pass_fd(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      pass_fd() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_pass_fd();

  // repeated .nsjail.IdMap uidmap = 54;
  int uidmap_size() const;
  private:
  int _internal_uidmap_size() const;
  public:
  void clear_uidmap();
  ::nsjail::IdMap* mutable_uidmap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >*
      mutable_uidmap();
  private:
  const ::nsjail::IdMap& _internal_uidmap(int index) const;
  ::nsjail::IdMap* _internal_add_uidmap();
  public:
  const ::nsjail::IdMap& uidmap(int index) const;
  ::nsjail::IdMap* add_uidmap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >&
      uidmap() const;

  // repeated .nsjail.IdMap gidmap = 55;
  int gidmap_size() const;
  private:
  int _internal_gidmap_size() const;
  public:
  void clear_gidmap();
  ::nsjail::IdMap* mutable_gidmap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >*
      mutable_gidmap();
  private:
  const ::nsjail::IdMap& _internal_gidmap(int index) const;
  ::nsjail::IdMap* _internal_add_gidmap();
  public:
  const ::nsjail::IdMap& gidmap(int index) const;
  ::nsjail::IdMap* add_gidmap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >&
      gidmap() const;

  // repeated .nsjail.MountPt mount = 57;
  int mount_size() const;
  private:
  int _internal_mount_size() const;
  public:
  void clear_mount();
  ::nsjail::MountPt* mutable_mount(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::MountPt >*
      mutable_mount();
  private:
  const ::nsjail::MountPt& _internal_mount(int index) const;
  ::nsjail::MountPt* _internal_add_mount();
  public:
  const ::nsjail::MountPt& mount(int index) const;
  ::nsjail::MountPt* add_mount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::MountPt >&
      mount() const;

  // repeated string seccomp_string = 59;
  int seccomp_string_size() const;
  private:
  int _internal_seccomp_string_size() const;
  public:
  void clear_seccomp_string();
  const std::string& seccomp_string(int index) const;
  std::string* mutable_seccomp_string(int index);
  void set_seccomp_string(int index, const std::string& value);
  void set_seccomp_string(int index, std::string&& value);
  void set_seccomp_string(int index, const char* value);
  void set_seccomp_string(int index, const char* value, size_t size);
  std::string* add_seccomp_string();
  void add_seccomp_string(const std::string& value);
  void add_seccomp_string(std::string&& value);
  void add_seccomp_string(const char* value);
  void add_seccomp_string(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& seccomp_string() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_seccomp_string();
  private:
  const std::string& _internal_seccomp_string(int index) const;
  std::string* _internal_add_seccomp_string();
  public:

  // repeated string iface_own = 76;
  int iface_own_size() const;
  private:
  int _internal_iface_own_size() const;
  public:
  void clear_iface_own();
  const std::string& iface_own(int index) const;
  std::string* mutable_iface_own(int index);
  void set_iface_own(int index, const std::string& value);
  void set_iface_own(int index, std::string&& value);
  void set_iface_own(int index, const char* value);
  void set_iface_own(int index, const char* value, size_t size);
  std::string* add_iface_own();
  void add_iface_own(const std::string& value);
  void add_iface_own(std::string&& value);
  void add_iface_own(const char* value);
  void add_iface_own(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& iface_own() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_iface_own();
  private:
  const std::string& _internal_iface_own(int index) const;
  std::string* _internal_add_iface_own();
  public:

  // optional string name = 1 [default = ""];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string hostname = 8 [default = "NSJAIL"];
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // optional string cwd = 9 [default = "/"];
  bool has_cwd() const;
  private:
  bool _internal_has_cwd() const;
  public:
  void clear_cwd();
  const std::string& cwd() const;
  void set_cwd(const std::string& value);
  void set_cwd(std::string&& value);
  void set_cwd(const char* value);
  void set_cwd(const char* value, size_t size);
  std::string* mutable_cwd();
  std::string* release_cwd();
  void set_allocated_cwd(std::string* cwd);
  private:
  const std::string& _internal_cwd() const;
  void _internal_set_cwd(const std::string& value);
  std::string* _internal_mutable_cwd();
  public:

  // optional string bindhost = 11 [default = "::"];
  bool has_bindhost() const;
  private:
  bool _internal_has_bindhost() const;
  public:
  void clear_bindhost();
  const std::string& bindhost() const;
  void set_bindhost(const std::string& value);
  void set_bindhost(std::string&& value);
  void set_bindhost(const char* value);
  void set_bindhost(const char* value, size_t size);
  std::string* mutable_bindhost();
  std::string* release_bindhost();
  void set_allocated_bindhost(std::string* bindhost);
  private:
  const std::string& _internal_bindhost() const;
  void _internal_set_bindhost(const std::string& value);
  std::string* _internal_mutable_bindhost();
  public:

  // optional string log_file = 17;
  bool has_log_file() const;
  private:
  bool _internal_has_log_file() const;
  public:
  void clear_log_file();
  const std::string& log_file() const;
  void set_log_file(const std::string& value);
  void set_log_file(std::string&& value);
  void set_log_file(const char* value);
  void set_log_file(const char* value, size_t size);
  std::string* mutable_log_file();
  std::string* release_log_file();
  void set_allocated_log_file(std::string* log_file);
  private:
  const std::string& _internal_log_file() const;
  void _internal_set_log_file(const std::string& value);
  std::string* _internal_mutable_log_file();
  public:

  // optional string seccomp_policy_file = 58;
  bool has_seccomp_policy_file() const;
  private:
  bool _internal_has_seccomp_policy_file() const;
  public:
  void clear_seccomp_policy_file();
  const std::string& seccomp_policy_file() const;
  void set_seccomp_policy_file(const std::string& value);
  void set_seccomp_policy_file(std::string&& value);
  void set_seccomp_policy_file(const char* value);
  void set_seccomp_policy_file(const char* value, size_t size);
  std::string* mutable_seccomp_policy_file();
  std::string* release_seccomp_policy_file();
  void set_allocated_seccomp_policy_file(std::string* seccomp_policy_file);
  private:
  const std::string& _internal_seccomp_policy_file() const;
  void _internal_set_seccomp_policy_file(const std::string& value);
  std::string* _internal_mutable_seccomp_policy_file();
  public:

  // optional string cgroup_mem_mount = 62 [default = "/sys/fs/cgroup/memory"];
  bool has_cgroup_mem_mount() const;
  private:
  bool _internal_has_cgroup_mem_mount() const;
  public:
  void clear_cgroup_mem_mount();
  const std::string& cgroup_mem_mount() const;
  void set_cgroup_mem_mount(const std::string& value);
  void set_cgroup_mem_mount(std::string&& value);
  void set_cgroup_mem_mount(const char* value);
  void set_cgroup_mem_mount(const char* value, size_t size);
  std::string* mutable_cgroup_mem_mount();
  std::string* release_cgroup_mem_mount();
  void set_allocated_cgroup_mem_mount(std::string* cgroup_mem_mount);
  private:
  const std::string& _internal_cgroup_mem_mount() const;
  void _internal_set_cgroup_mem_mount(const std::string& value);
  std::string* _internal_mutable_cgroup_mem_mount();
  public:

  // optional string cgroup_mem_parent = 63 [default = "NSJAIL"];
  bool has_cgroup_mem_parent() const;
  private:
  bool _internal_has_cgroup_mem_parent() const;
  public:
  void clear_cgroup_mem_parent();
  const std::string& cgroup_mem_parent() const;
  void set_cgroup_mem_parent(const std::string& value);
  void set_cgroup_mem_parent(std::string&& value);
  void set_cgroup_mem_parent(const char* value);
  void set_cgroup_mem_parent(const char* value, size_t size);
  std::string* mutable_cgroup_mem_parent();
  std::string* release_cgroup_mem_parent();
  void set_allocated_cgroup_mem_parent(std::string* cgroup_mem_parent);
  private:
  const std::string& _internal_cgroup_mem_parent() const;
  void _internal_set_cgroup_mem_parent(const std::string& value);
  std::string* _internal_mutable_cgroup_mem_parent();
  public:

  // optional string cgroup_pids_mount = 65 [default = "/sys/fs/cgroup/pids"];
  bool has_cgroup_pids_mount() const;
  private:
  bool _internal_has_cgroup_pids_mount() const;
  public:
  void clear_cgroup_pids_mount();
  const std::string& cgroup_pids_mount() const;
  void set_cgroup_pids_mount(const std::string& value);
  void set_cgroup_pids_mount(std::string&& value);
  void set_cgroup_pids_mount(const char* value);
  void set_cgroup_pids_mount(const char* value, size_t size);
  std::string* mutable_cgroup_pids_mount();
  std::string* release_cgroup_pids_mount();
  void set_allocated_cgroup_pids_mount(std::string* cgroup_pids_mount);
  private:
  const std::string& _internal_cgroup_pids_mount() const;
  void _internal_set_cgroup_pids_mount(const std::string& value);
  std::string* _internal_mutable_cgroup_pids_mount();
  public:

  // optional string cgroup_pids_parent = 66 [default = "NSJAIL"];
  bool has_cgroup_pids_parent() const;
  private:
  bool _internal_has_cgroup_pids_parent() const;
  public:
  void clear_cgroup_pids_parent();
  const std::string& cgroup_pids_parent() const;
  void set_cgroup_pids_parent(const std::string& value);
  void set_cgroup_pids_parent(std::string&& value);
  void set_cgroup_pids_parent(const char* value);
  void set_cgroup_pids_parent(const char* value, size_t size);
  std::string* mutable_cgroup_pids_parent();
  std::string* release_cgroup_pids_parent();
  void set_allocated_cgroup_pids_parent(std::string* cgroup_pids_parent);
  private:
  const std::string& _internal_cgroup_pids_parent() const;
  void _internal_set_cgroup_pids_parent(const std::string& value);
  std::string* _internal_mutable_cgroup_pids_parent();
  public:

  // optional string cgroup_net_cls_mount = 68 [default = "/sys/fs/cgroup/net_cls"];
  bool has_cgroup_net_cls_mount() const;
  private:
  bool _internal_has_cgroup_net_cls_mount() const;
  public:
  void clear_cgroup_net_cls_mount();
  const std::string& cgroup_net_cls_mount() const;
  void set_cgroup_net_cls_mount(const std::string& value);
  void set_cgroup_net_cls_mount(std::string&& value);
  void set_cgroup_net_cls_mount(const char* value);
  void set_cgroup_net_cls_mount(const char* value, size_t size);
  std::string* mutable_cgroup_net_cls_mount();
  std::string* release_cgroup_net_cls_mount();
  void set_allocated_cgroup_net_cls_mount(std::string* cgroup_net_cls_mount);
  private:
  const std::string& _internal_cgroup_net_cls_mount() const;
  void _internal_set_cgroup_net_cls_mount(const std::string& value);
  std::string* _internal_mutable_cgroup_net_cls_mount();
  public:

  // optional string cgroup_net_cls_parent = 69 [default = "NSJAIL"];
  bool has_cgroup_net_cls_parent() const;
  private:
  bool _internal_has_cgroup_net_cls_parent() const;
  public:
  void clear_cgroup_net_cls_parent();
  const std::string& cgroup_net_cls_parent() const;
  void set_cgroup_net_cls_parent(const std::string& value);
  void set_cgroup_net_cls_parent(std::string&& value);
  void set_cgroup_net_cls_parent(const char* value);
  void set_cgroup_net_cls_parent(const char* value, size_t size);
  std::string* mutable_cgroup_net_cls_parent();
  std::string* release_cgroup_net_cls_parent();
  void set_allocated_cgroup_net_cls_parent(std::string* cgroup_net_cls_parent);
  private:
  const std::string& _internal_cgroup_net_cls_parent() const;
  void _internal_set_cgroup_net_cls_parent(const std::string& value);
  std::string* _internal_mutable_cgroup_net_cls_parent();
  public:

  // optional string cgroup_cpu_mount = 71 [default = "/sys/fs/cgroup/cpu"];
  bool has_cgroup_cpu_mount() const;
  private:
  bool _internal_has_cgroup_cpu_mount() const;
  public:
  void clear_cgroup_cpu_mount();
  const std::string& cgroup_cpu_mount() const;
  void set_cgroup_cpu_mount(const std::string& value);
  void set_cgroup_cpu_mount(std::string&& value);
  void set_cgroup_cpu_mount(const char* value);
  void set_cgroup_cpu_mount(const char* value, size_t size);
  std::string* mutable_cgroup_cpu_mount();
  std::string* release_cgroup_cpu_mount();
  void set_allocated_cgroup_cpu_mount(std::string* cgroup_cpu_mount);
  private:
  const std::string& _internal_cgroup_cpu_mount() const;
  void _internal_set_cgroup_cpu_mount(const std::string& value);
  std::string* _internal_mutable_cgroup_cpu_mount();
  public:

  // optional string cgroup_cpu_parent = 72 [default = "NSJAIL"];
  bool has_cgroup_cpu_parent() const;
  private:
  bool _internal_has_cgroup_cpu_parent() const;
  public:
  void clear_cgroup_cpu_parent();
  const std::string& cgroup_cpu_parent() const;
  void set_cgroup_cpu_parent(const std::string& value);
  void set_cgroup_cpu_parent(std::string&& value);
  void set_cgroup_cpu_parent(const char* value);
  void set_cgroup_cpu_parent(const char* value, size_t size);
  std::string* mutable_cgroup_cpu_parent();
  std::string* release_cgroup_cpu_parent();
  void set_allocated_cgroup_cpu_parent(std::string* cgroup_cpu_parent);
  private:
  const std::string& _internal_cgroup_cpu_parent() const;
  void _internal_set_cgroup_cpu_parent(const std::string& value);
  std::string* _internal_mutable_cgroup_cpu_parent();
  public:

  // optional string cgroupv2_mount = 73 [default = "/sys/fs/cgroup"];
  bool has_cgroupv2_mount() const;
  private:
  bool _internal_has_cgroupv2_mount() const;
  public:
  void clear_cgroupv2_mount();
  const std::string& cgroupv2_mount() const;
  void set_cgroupv2_mount(const std::string& value);
  void set_cgroupv2_mount(std::string&& value);
  void set_cgroupv2_mount(const char* value);
  void set_cgroupv2_mount(const char* value, size_t size);
  std::string* mutable_cgroupv2_mount();
  std::string* release_cgroupv2_mount();
  void set_allocated_cgroupv2_mount(std::string* cgroupv2_mount);
  private:
  const std::string& _internal_cgroupv2_mount() const;
  void _internal_set_cgroupv2_mount(const std::string& value);
  std::string* _internal_mutable_cgroupv2_mount();
  public:

  // optional string macvlan_iface = 77;
  bool has_macvlan_iface() const;
  private:
  bool _internal_has_macvlan_iface() const;
  public:
  void clear_macvlan_iface();
  const std::string& macvlan_iface() const;
  void set_macvlan_iface(const std::string& value);
  void set_macvlan_iface(std::string&& value);
  void set_macvlan_iface(const char* value);
  void set_macvlan_iface(const char* value, size_t size);
  std::string* mutable_macvlan_iface();
  std::string* release_macvlan_iface();
  void set_allocated_macvlan_iface(std::string* macvlan_iface);
  private:
  const std::string& _internal_macvlan_iface() const;
  void _internal_set_macvlan_iface(const std::string& value);
  std::string* _internal_mutable_macvlan_iface();
  public:

  // optional string macvlan_vs_ip = 78 [default = "192.168.0.2"];
  bool has_macvlan_vs_ip() const;
  private:
  bool _internal_has_macvlan_vs_ip() const;
  public:
  void clear_macvlan_vs_ip();
  const std::string& macvlan_vs_ip() const;
  void set_macvlan_vs_ip(const std::string& value);
  void set_macvlan_vs_ip(std::string&& value);
  void set_macvlan_vs_ip(const char* value);
  void set_macvlan_vs_ip(const char* value, size_t size);
  std::string* mutable_macvlan_vs_ip();
  std::string* release_macvlan_vs_ip();
  void set_allocated_macvlan_vs_ip(std::string* macvlan_vs_ip);
  private:
  const std::string& _internal_macvlan_vs_ip() const;
  void _internal_set_macvlan_vs_ip(const std::string& value);
  std::string* _internal_mutable_macvlan_vs_ip();
  public:

  // optional string macvlan_vs_nm = 79 [default = "255.255.255.0"];
  bool has_macvlan_vs_nm() const;
  private:
  bool _internal_has_macvlan_vs_nm() const;
  public:
  void clear_macvlan_vs_nm();
  const std::string& macvlan_vs_nm() const;
  void set_macvlan_vs_nm(const std::string& value);
  void set_macvlan_vs_nm(std::string&& value);
  void set_macvlan_vs_nm(const char* value);
  void set_macvlan_vs_nm(const char* value, size_t size);
  std::string* mutable_macvlan_vs_nm();
  std::string* release_macvlan_vs_nm();
  void set_allocated_macvlan_vs_nm(std::string* macvlan_vs_nm);
  private:
  const std::string& _internal_macvlan_vs_nm() const;
  void _internal_set_macvlan_vs_nm(const std::string& value);
  std::string* _internal_mutable_macvlan_vs_nm();
  public:

  // optional string macvlan_vs_gw = 80 [default = "192.168.0.1"];
  bool has_macvlan_vs_gw() const;
  private:
  bool _internal_has_macvlan_vs_gw() const;
  public:
  void clear_macvlan_vs_gw();
  const std::string& macvlan_vs_gw() const;
  void set_macvlan_vs_gw(const std::string& value);
  void set_macvlan_vs_gw(std::string&& value);
  void set_macvlan_vs_gw(const char* value);
  void set_macvlan_vs_gw(const char* value, size_t size);
  std::string* mutable_macvlan_vs_gw();
  std::string* release_macvlan_vs_gw();
  void set_allocated_macvlan_vs_gw(std::string* macvlan_vs_gw);
  private:
  const std::string& _internal_macvlan_vs_gw() const;
  void _internal_set_macvlan_vs_gw(const std::string& value);
  std::string* _internal_mutable_macvlan_vs_gw();
  public:

  // optional string macvlan_vs_ma = 81 [default = ""];
  bool has_macvlan_vs_ma() const;
  private:
  bool _internal_has_macvlan_vs_ma() const;
  public:
  void clear_macvlan_vs_ma();
  const std::string& macvlan_vs_ma() const;
  void set_macvlan_vs_ma(const std::string& value);
  void set_macvlan_vs_ma(std::string&& value);
  void set_macvlan_vs_ma(const char* value);
  void set_macvlan_vs_ma(const char* value, size_t size);
  std::string* mutable_macvlan_vs_ma();
  std::string* release_macvlan_vs_ma();
  void set_allocated_macvlan_vs_ma(std::string* macvlan_vs_ma);
  private:
  const std::string& _internal_macvlan_vs_ma() const;
  void _internal_set_macvlan_vs_ma(const std::string& value);
  std::string* _internal_mutable_macvlan_vs_ma();
  public:

  // optional .nsjail.Exe exec_bin = 83;
  bool has_exec_bin() const;
  private:
  bool _internal_has_exec_bin() const;
  public:
  void clear_exec_bin();
  const ::nsjail::Exe& exec_bin() const;
  ::nsjail::Exe* release_exec_bin();
  ::nsjail::Exe* mutable_exec_bin();
  void set_allocated_exec_bin(::nsjail::Exe* exec_bin);
  private:
  const ::nsjail::Exe& _internal_exec_bin() const;
  ::nsjail::Exe* _internal_mutable_exec_bin();
  public:
  void unsafe_arena_set_allocated_exec_bin(
      ::nsjail::Exe* exec_bin);
  ::nsjail::Exe* unsafe_arena_release_exec_bin();

  // optional uint32 port = 10 [default = 0];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 max_conns_per_ip = 12 [default = 0];
  bool has_max_conns_per_ip() const;
  private:
  bool _internal_has_max_conns_per_ip() const;
  public:
  void clear_max_conns_per_ip();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_conns_per_ip() const;
  void set_max_conns_per_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_conns_per_ip() const;
  void _internal_set_max_conns_per_ip(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 max_cpus = 15 [default = 0];
  bool has_max_cpus() const;
  private:
  bool _internal_has_max_cpus() const;
  public:
  void clear_max_cpus();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_cpus() const;
  void set_max_cpus(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_cpus() const;
  void _internal_set_max_cpus(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 log_fd = 16;
  bool has_log_fd() const;
  private:
  bool _internal_has_log_fd() const;
  public:
  void clear_log_fd();
  ::PROTOBUF_NAMESPACE_ID::int32 log_fd() const;
  void set_log_fd(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_log_fd() const;
  void _internal_set_log_fd(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .nsjail.LogLevel log_level = 18;
  bool has_log_level() const;
  private:
  bool _internal_has_log_level() const;
  public:
  void clear_log_level();
  ::nsjail::LogLevel log_level() const;
  void set_log_level(::nsjail::LogLevel value);
  private:
  ::nsjail::LogLevel _internal_log_level() const;
  void _internal_set_log_level(::nsjail::LogLevel value);
  public:

  // optional bool daemon = 14 [default = false];
  bool has_daemon() const;
  private:
  bool _internal_has_daemon() const;
  public:
  void clear_daemon();
  bool daemon() const;
  void set_daemon(bool value);
  private:
  bool _internal_daemon() const;
  void _internal_set_daemon(bool value);
  public:

  // optional bool keep_env = 19 [default = false];
  bool has_keep_env() const;
  private:
  bool _internal_has_keep_env() const;
  public:
  void clear_keep_env();
  bool keep_env() const;
  void set_keep_env(bool value);
  private:
  bool _internal_keep_env() const;
  void _internal_set_keep_env(bool value);
  public:

  // optional bool keep_caps = 21 [default = false];
  bool has_keep_caps() const;
  private:
  bool _internal_has_keep_caps() const;
  public:
  void clear_keep_caps();
  bool keep_caps() const;
  void set_keep_caps(bool value);
  private:
  bool _internal_keep_caps() const;
  void _internal_set_keep_caps(bool value);
  public:

  // optional bool silent = 23 [default = false];
  bool has_silent() const;
  private:
  bool _internal_has_silent() const;
  public:
  void clear_silent();
  bool silent() const;
  void set_silent(bool value);
  private:
  bool _internal_silent() const;
  void _internal_set_silent(bool value);
  public:

  // optional uint64 rlimit_core = 30 [default = 0];
  bool has_rlimit_core() const;
  private:
  bool _internal_has_rlimit_core() const;
  public:
  void clear_rlimit_core();
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_core() const;
  void set_rlimit_core(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rlimit_core() const;
  void _internal_set_rlimit_core(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .nsjail.RLimit rlimit_as_type = 29 [default = VALUE];
  bool has_rlimit_as_type() const;
  private:
  bool _internal_has_rlimit_as_type() const;
  public:
  void clear_rlimit_as_type();
  ::nsjail::RLimit rlimit_as_type() const;
  void set_rlimit_as_type(::nsjail::RLimit value);
  private:
  ::nsjail::RLimit _internal_rlimit_as_type() const;
  void _internal_set_rlimit_as_type(::nsjail::RLimit value);
  public:

  // optional .nsjail.RLimit rlimit_core_type = 31 [default = VALUE];
  bool has_rlimit_core_type() const;
  private:
  bool _internal_has_rlimit_core_type() const;
  public:
  void clear_rlimit_core_type();
  ::nsjail::RLimit rlimit_core_type() const;
  void set_rlimit_core_type(::nsjail::RLimit value);
  private:
  ::nsjail::RLimit _internal_rlimit_core_type() const;
  void _internal_set_rlimit_core_type(::nsjail::RLimit value);
  public:

  // optional .nsjail.RLimit rlimit_cpu_type = 33 [default = VALUE];
  bool has_rlimit_cpu_type() const;
  private:
  bool _internal_has_rlimit_cpu_type() const;
  public:
  void clear_rlimit_cpu_type();
  ::nsjail::RLimit rlimit_cpu_type() const;
  void set_rlimit_cpu_type(::nsjail::RLimit value);
  private:
  ::nsjail::RLimit _internal_rlimit_cpu_type() const;
  void _internal_set_rlimit_cpu_type(::nsjail::RLimit value);
  public:

  // optional .nsjail.RLimit rlimit_fsize_type = 35 [default = VALUE];
  bool has_rlimit_fsize_type() const;
  private:
  bool _internal_has_rlimit_fsize_type() const;
  public:
  void clear_rlimit_fsize_type();
  ::nsjail::RLimit rlimit_fsize_type() const;
  void set_rlimit_fsize_type(::nsjail::RLimit value);
  private:
  ::nsjail::RLimit _internal_rlimit_fsize_type() const;
  void _internal_set_rlimit_fsize_type(::nsjail::RLimit value);
  public:

  // optional .nsjail.RLimit rlimit_nofile_type = 37 [default = VALUE];
  bool has_rlimit_nofile_type() const;
  private:
  bool _internal_has_rlimit_nofile_type() const;
  public:
  void clear_rlimit_nofile_type();
  ::nsjail::RLimit rlimit_nofile_type() const;
  void set_rlimit_nofile_type(::nsjail::RLimit value);
  private:
  ::nsjail::RLimit _internal_rlimit_nofile_type() const;
  void _internal_set_rlimit_nofile_type(::nsjail::RLimit value);
  public:

  // optional bool skip_setsid = 24 [default = false];
  bool has_skip_setsid() const;
  private:
  bool _internal_has_skip_setsid() const;
  public:
  void clear_skip_setsid();
  bool skip_setsid() const;
  void set_skip_setsid(bool value);
  private:
  bool _internal_skip_setsid() const;
  void _internal_set_skip_setsid(bool value);
  public:

  // optional bool stderr_to_null = 25 [default = false];
  bool has_stderr_to_null() const;
  private:
  bool _internal_has_stderr_to_null() const;
  public:
  void clear_stderr_to_null();
  bool stderr_to_null() const;
  void set_stderr_to_null(bool value);
  private:
  bool _internal_stderr_to_null() const;
  void _internal_set_stderr_to_null(bool value);
  public:

  // optional bool disable_no_new_privs = 27 [default = false];
  bool has_disable_no_new_privs() const;
  private:
  bool _internal_has_disable_no_new_privs() const;
  public:
  void clear_disable_no_new_privs();
  bool disable_no_new_privs() const;
  void set_disable_no_new_privs(bool value);
  private:
  bool _internal_disable_no_new_privs() const;
  void _internal_set_disable_no_new_privs(bool value);
  public:

  // optional bool disable_rl = 84 [default = false];
  bool has_disable_rl() const;
  private:
  bool _internal_has_disable_rl() const;
  public:
  void clear_disable_rl();
  bool disable_rl() const;
  void set_disable_rl(bool value);
  private:
  bool _internal_disable_rl() const;
  void _internal_set_disable_rl(bool value);
  public:

  // optional bool persona_addr_compat_layout = 42 [default = false];
  bool has_persona_addr_compat_layout() const;
  private:
  bool _internal_has_persona_addr_compat_layout() const;
  public:
  void clear_persona_addr_compat_layout();
  bool persona_addr_compat_layout() const;
  void set_persona_addr_compat_layout(bool value);
  private:
  bool _internal_persona_addr_compat_layout() const;
  void _internal_set_persona_addr_compat_layout(bool value);
  public:

  // optional bool persona_mmap_page_zero = 43 [default = false];
  bool has_persona_mmap_page_zero() const;
  private:
  bool _internal_has_persona_mmap_page_zero() const;
  public:
  void clear_persona_mmap_page_zero();
  bool persona_mmap_page_zero() const;
  void set_persona_mmap_page_zero(bool value);
  private:
  bool _internal_persona_mmap_page_zero() const;
  void _internal_set_persona_mmap_page_zero(bool value);
  public:

  // optional bool persona_read_implies_exec = 44 [default = false];
  bool has_persona_read_implies_exec() const;
  private:
  bool _internal_has_persona_read_implies_exec() const;
  public:
  void clear_persona_read_implies_exec();
  bool persona_read_implies_exec() const;
  void set_persona_read_implies_exec(bool value);
  private:
  bool _internal_persona_read_implies_exec() const;
  void _internal_set_persona_read_implies_exec(bool value);
  public:

  // optional bool persona_addr_limit_3gb = 45 [default = false];
  bool has_persona_addr_limit_3gb() const;
  private:
  bool _internal_has_persona_addr_limit_3gb() const;
  public:
  void clear_persona_addr_limit_3gb();
  bool persona_addr_limit_3gb() const;
  void set_persona_addr_limit_3gb(bool value);
  private:
  bool _internal_persona_addr_limit_3gb() const;
  void _internal_set_persona_addr_limit_3gb(bool value);
  public:

  // optional bool persona_addr_no_randomize = 46 [default = false];
  bool has_persona_addr_no_randomize() const;
  private:
  bool _internal_has_persona_addr_no_randomize() const;
  public:
  void clear_persona_addr_no_randomize();
  bool persona_addr_no_randomize() const;
  void set_persona_addr_no_randomize(bool value);
  private:
  bool _internal_persona_addr_no_randomize() const;
  void _internal_set_persona_addr_no_randomize(bool value);
  public:

  // optional bool mount_proc = 56 [default = false];
  bool has_mount_proc() const;
  private:
  bool _internal_has_mount_proc() const;
  public:
  void clear_mount_proc();
  bool mount_proc() const;
  void set_mount_proc(bool value);
  private:
  bool _internal_mount_proc() const;
  void _internal_set_mount_proc(bool value);
  public:

  // optional bool seccomp_log = 60 [default = false];
  bool has_seccomp_log() const;
  private:
  bool _internal_has_seccomp_log() const;
  public:
  void clear_seccomp_log();
  bool seccomp_log() const;
  void set_seccomp_log(bool value);
  private:
  bool _internal_seccomp_log() const;
  void _internal_set_seccomp_log(bool value);
  public:

  // optional bool use_cgroupv2 = 74 [default = false];
  bool has_use_cgroupv2() const;
  private:
  bool _internal_has_use_cgroupv2() const;
  public:
  void clear_use_cgroupv2();
  bool use_cgroupv2() const;
  void set_use_cgroupv2(bool value);
  private:
  bool _internal_use_cgroupv2() const;
  void _internal_set_use_cgroupv2(bool value);
  public:

  // optional uint64 cgroup_mem_max = 61 [default = 0];
  bool has_cgroup_mem_max() const;
  private:
  bool _internal_has_cgroup_mem_max() const;
  public:
  void clear_cgroup_mem_max();
  ::PROTOBUF_NAMESPACE_ID::uint64 cgroup_mem_max() const;
  void set_cgroup_mem_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_cgroup_mem_max() const;
  void _internal_set_cgroup_mem_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 cgroup_pids_max = 64 [default = 0];
  bool has_cgroup_pids_max() const;
  private:
  bool _internal_has_cgroup_pids_max() const;
  public:
  void clear_cgroup_pids_max();
  ::PROTOBUF_NAMESPACE_ID::uint64 cgroup_pids_max() const;
  void set_cgroup_pids_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_cgroup_pids_max() const;
  void _internal_set_cgroup_pids_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 cgroup_net_cls_classid = 67 [default = 0];
  bool has_cgroup_net_cls_classid() const;
  private:
  bool _internal_has_cgroup_net_cls_classid() const;
  public:
  void clear_cgroup_net_cls_classid();
  ::PROTOBUF_NAMESPACE_ID::uint32 cgroup_net_cls_classid() const;
  void set_cgroup_net_cls_classid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cgroup_net_cls_classid() const;
  void _internal_set_cgroup_net_cls_classid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 cgroup_cpu_ms_per_sec = 70 [default = 0];
  bool has_cgroup_cpu_ms_per_sec() const;
  private:
  bool _internal_has_cgroup_cpu_ms_per_sec() const;
  public:
  void clear_cgroup_cpu_ms_per_sec();
  ::PROTOBUF_NAMESPACE_ID::uint32 cgroup_cpu_ms_per_sec() const;
  void set_cgroup_cpu_ms_per_sec(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cgroup_cpu_ms_per_sec() const;
  void _internal_set_cgroup_cpu_ms_per_sec(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool iface_no_lo = 75 [default = false];
  bool has_iface_no_lo() const;
  private:
  bool _internal_has_iface_no_lo() const;
  public:
  void clear_iface_no_lo();
  bool iface_no_lo() const;
  void set_iface_no_lo(bool value);
  private:
  bool _internal_iface_no_lo() const;
  void _internal_set_iface_no_lo(bool value);
  public:

  // optional int32 nice_level = 82 [default = 19];
  bool has_nice_level() const;
  private:
  bool _internal_has_nice_level() const;
  public:
  void clear_nice_level();
  ::PROTOBUF_NAMESPACE_ID::int32 nice_level() const;
  void set_nice_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nice_level() const;
  void _internal_set_nice_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .nsjail.Mode mode = 3 [default = ONCE];
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::nsjail::Mode mode() const;
  void set_mode(::nsjail::Mode value);
  private:
  ::nsjail::Mode _internal_mode() const;
  void _internal_set_mode(::nsjail::Mode value);
  public:

  // optional uint32 time_limit = 13 [default = 600];
  bool has_time_limit() const;
  private:
  bool _internal_has_time_limit() const;
  public:
  void clear_time_limit();
  ::PROTOBUF_NAMESPACE_ID::uint32 time_limit() const;
  void set_time_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time_limit() const;
  void _internal_set_time_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 rlimit_as = 28 [default = 4096];
  bool has_rlimit_as() const;
  private:
  bool _internal_has_rlimit_as() const;
  public:
  void clear_rlimit_as();
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_as() const;
  void set_rlimit_as(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rlimit_as() const;
  void _internal_set_rlimit_as(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 rlimit_cpu = 32 [default = 600];
  bool has_rlimit_cpu() const;
  private:
  bool _internal_has_rlimit_cpu() const;
  public:
  void clear_rlimit_cpu();
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_cpu() const;
  void set_rlimit_cpu(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rlimit_cpu() const;
  void _internal_set_rlimit_cpu(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 rlimit_fsize = 34 [default = 1];
  bool has_rlimit_fsize() const;
  private:
  bool _internal_has_rlimit_fsize() const;
  public:
  void clear_rlimit_fsize();
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_fsize() const;
  void set_rlimit_fsize(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rlimit_fsize() const;
  void _internal_set_rlimit_fsize(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 rlimit_nofile = 36 [default = 32];
  bool has_rlimit_nofile() const;
  private:
  bool _internal_has_rlimit_nofile() const;
  public:
  void clear_rlimit_nofile();
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_nofile() const;
  void set_rlimit_nofile(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rlimit_nofile() const;
  void _internal_set_rlimit_nofile(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 rlimit_nproc = 38 [default = 1024];
  bool has_rlimit_nproc() const;
  private:
  bool _internal_has_rlimit_nproc() const;
  public:
  void clear_rlimit_nproc();
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_nproc() const;
  void set_rlimit_nproc(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rlimit_nproc() const;
  void _internal_set_rlimit_nproc(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 rlimit_stack = 40 [default = 8];
  bool has_rlimit_stack() const;
  private:
  bool _internal_has_rlimit_stack() const;
  public:
  void clear_rlimit_stack();
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_stack() const;
  void set_rlimit_stack(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rlimit_stack() const;
  void _internal_set_rlimit_stack(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .nsjail.RLimit rlimit_nproc_type = 39 [default = SOFT];
  bool has_rlimit_nproc_type() const;
  private:
  bool _internal_has_rlimit_nproc_type() const;
  public:
  void clear_rlimit_nproc_type();
  ::nsjail::RLimit rlimit_nproc_type() const;
  void set_rlimit_nproc_type(::nsjail::RLimit value);
  private:
  ::nsjail::RLimit _internal_rlimit_nproc_type() const;
  void _internal_set_rlimit_nproc_type(::nsjail::RLimit value);
  public:

  // optional .nsjail.RLimit rlimit_stack_type = 41 [default = SOFT];
  bool has_rlimit_stack_type() const;
  private:
  bool _internal_has_rlimit_stack_type() const;
  public:
  void clear_rlimit_stack_type();
  ::nsjail::RLimit rlimit_stack_type() const;
  void set_rlimit_stack_type(::nsjail::RLimit value);
  private:
  ::nsjail::RLimit _internal_rlimit_stack_type() const;
  void _internal_set_rlimit_stack_type(::nsjail::RLimit value);
  public:

  // optional bool clone_newnet = 47 [default = true];
  bool has_clone_newnet() const;
  private:
  bool _internal_has_clone_newnet() const;
  public:
  void clear_clone_newnet();
  bool clone_newnet() const;
  void set_clone_newnet(bool value);
  private:
  bool _internal_clone_newnet() const;
  void _internal_set_clone_newnet(bool value);
  public:

  // optional bool clone_newuser = 48 [default = true];
  bool has_clone_newuser() const;
  private:
  bool _internal_has_clone_newuser() const;
  public:
  void clear_clone_newuser();
  bool clone_newuser() const;
  void set_clone_newuser(bool value);
  private:
  bool _internal_clone_newuser() const;
  void _internal_set_clone_newuser(bool value);
  public:

  // optional bool clone_newns = 49 [default = true];
  bool has_clone_newns() const;
  private:
  bool _internal_has_clone_newns() const;
  public:
  void clear_clone_newns();
  bool clone_newns() const;
  void set_clone_newns(bool value);
  private:
  bool _internal_clone_newns() const;
  void _internal_set_clone_newns(bool value);
  public:

  // optional bool clone_newpid = 50 [default = true];
  bool has_clone_newpid() const;
  private:
  bool _internal_has_clone_newpid() const;
  public:
  void clear_clone_newpid();
  bool clone_newpid() const;
  void set_clone_newpid(bool value);
  private:
  bool _internal_clone_newpid() const;
  void _internal_set_clone_newpid(bool value);
  public:

  // optional bool clone_newipc = 51 [default = true];
  bool has_clone_newipc() const;
  private:
  bool _internal_has_clone_newipc() const;
  public:
  void clear_clone_newipc();
  bool clone_newipc() const;
  void set_clone_newipc(bool value);
  private:
  bool _internal_clone_newipc() const;
  void _internal_set_clone_newipc(bool value);
  public:

  // optional bool clone_newuts = 52 [default = true];
  bool has_clone_newuts() const;
  private:
  bool _internal_has_clone_newuts() const;
  public:
  void clear_clone_newuts();
  bool clone_newuts() const;
  void set_clone_newuts(bool value);
  private:
  bool _internal_clone_newuts() const;
  void _internal_set_clone_newuts(bool value);
  public:

  // optional bool clone_newcgroup = 53 [default = true];
  bool has_clone_newcgroup() const;
  private:
  bool _internal_has_clone_newcgroup() const;
  public:
  void clear_clone_newcgroup();
  bool clone_newcgroup() const;
  void set_clone_newcgroup(bool value);
  private:
  bool _internal_clone_newcgroup() const;
  void _internal_set_clone_newcgroup(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nsjail.NsJailConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<3> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> description_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> envar_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cap_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > pass_fd_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap > uidmap_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap > gidmap_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::MountPt > mount_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> seccomp_string_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> iface_own_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cwd_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cwd_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_bindhost_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bindhost_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seccomp_policy_file_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_mem_mount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_mem_mount_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_mem_parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_mem_parent_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_pids_mount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_pids_mount_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_pids_parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_pids_parent_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_net_cls_mount_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_net_cls_parent_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_cpu_mount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_cpu_mount_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroup_cpu_parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroup_cpu_parent_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cgroupv2_mount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cgroupv2_mount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macvlan_iface_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_macvlan_vs_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macvlan_vs_ip_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_macvlan_vs_nm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macvlan_vs_nm_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_macvlan_vs_gw_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macvlan_vs_gw_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macvlan_vs_ma_;
  ::nsjail::Exe* exec_bin_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_conns_per_ip_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_cpus_;
  ::PROTOBUF_NAMESPACE_ID::int32 log_fd_;
  int log_level_;
  bool daemon_;
  bool keep_env_;
  bool keep_caps_;
  bool silent_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_core_;
  int rlimit_as_type_;
  int rlimit_core_type_;
  int rlimit_cpu_type_;
  int rlimit_fsize_type_;
  int rlimit_nofile_type_;
  bool skip_setsid_;
  bool stderr_to_null_;
  bool disable_no_new_privs_;
  bool disable_rl_;
  bool persona_addr_compat_layout_;
  bool persona_mmap_page_zero_;
  bool persona_read_implies_exec_;
  bool persona_addr_limit_3gb_;
  bool persona_addr_no_randomize_;
  bool mount_proc_;
  bool seccomp_log_;
  bool use_cgroupv2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cgroup_mem_max_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cgroup_pids_max_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cgroup_net_cls_classid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cgroup_cpu_ms_per_sec_;
  bool iface_no_lo_;
  ::PROTOBUF_NAMESPACE_ID::int32 nice_level_;
  int mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_as_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_cpu_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_fsize_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_nofile_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_nproc_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rlimit_stack_;
  int rlimit_nproc_type_;
  int rlimit_stack_type_;
  bool clone_newnet_;
  bool clone_newuser_;
  bool clone_newns_;
  bool clone_newpid_;
  bool clone_newipc_;
  bool clone_newuts_;
  bool clone_newcgroup_;
  friend struct ::TableStruct_config_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IdMap

// optional string inside_id = 1 [default = ""];
inline bool IdMap::_internal_has_inside_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IdMap::has_inside_id() const {
  return _internal_has_inside_id();
}
inline void IdMap::clear_inside_id() {
  inside_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IdMap::inside_id() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.inside_id)
  return _internal_inside_id();
}
inline void IdMap::set_inside_id(const std::string& value) {
  _internal_set_inside_id(value);
  // @@protoc_insertion_point(field_set:nsjail.IdMap.inside_id)
}
inline std::string* IdMap::mutable_inside_id() {
  // @@protoc_insertion_point(field_mutable:nsjail.IdMap.inside_id)
  return _internal_mutable_inside_id();
}
inline const std::string& IdMap::_internal_inside_id() const {
  return inside_id_.Get();
}
inline void IdMap::_internal_set_inside_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  inside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IdMap::set_inside_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  inside_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.IdMap.inside_id)
}
inline void IdMap::set_inside_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  inside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.IdMap.inside_id)
}
inline void IdMap::set_inside_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  inside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.IdMap.inside_id)
}
inline std::string* IdMap::_internal_mutable_inside_id() {
  _has_bits_[0] |= 0x00000001u;
  return inside_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IdMap::release_inside_id() {
  // @@protoc_insertion_point(field_release:nsjail.IdMap.inside_id)
  if (!_internal_has_inside_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return inside_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IdMap::set_allocated_inside_id(std::string* inside_id) {
  if (inside_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  inside_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), inside_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.IdMap.inside_id)
}

// optional string outside_id = 2 [default = ""];
inline bool IdMap::_internal_has_outside_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IdMap::has_outside_id() const {
  return _internal_has_outside_id();
}
inline void IdMap::clear_outside_id() {
  outside_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IdMap::outside_id() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.outside_id)
  return _internal_outside_id();
}
inline void IdMap::set_outside_id(const std::string& value) {
  _internal_set_outside_id(value);
  // @@protoc_insertion_point(field_set:nsjail.IdMap.outside_id)
}
inline std::string* IdMap::mutable_outside_id() {
  // @@protoc_insertion_point(field_mutable:nsjail.IdMap.outside_id)
  return _internal_mutable_outside_id();
}
inline const std::string& IdMap::_internal_outside_id() const {
  return outside_id_.Get();
}
inline void IdMap::_internal_set_outside_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  outside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void IdMap::set_outside_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  outside_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.IdMap.outside_id)
}
inline void IdMap::set_outside_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  outside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.IdMap.outside_id)
}
inline void IdMap::set_outside_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  outside_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.IdMap.outside_id)
}
inline std::string* IdMap::_internal_mutable_outside_id() {
  _has_bits_[0] |= 0x00000002u;
  return outside_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* IdMap::release_outside_id() {
  // @@protoc_insertion_point(field_release:nsjail.IdMap.outside_id)
  if (!_internal_has_outside_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return outside_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void IdMap::set_allocated_outside_id(std::string* outside_id) {
  if (outside_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  outside_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), outside_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.IdMap.outside_id)
}

// optional uint32 count = 3 [default = 1];
inline bool IdMap::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IdMap::has_count() const {
  return _internal_has_count();
}
inline void IdMap::clear_count() {
  count_ = 1u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IdMap::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 IdMap::count() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.count)
  return _internal_count();
}
inline void IdMap::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  count_ = value;
}
inline void IdMap::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:nsjail.IdMap.count)
}

// optional bool use_newidmap = 4 [default = false];
inline bool IdMap::_internal_has_use_newidmap() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IdMap::has_use_newidmap() const {
  return _internal_has_use_newidmap();
}
inline void IdMap::clear_use_newidmap() {
  use_newidmap_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool IdMap::_internal_use_newidmap() const {
  return use_newidmap_;
}
inline bool IdMap::use_newidmap() const {
  // @@protoc_insertion_point(field_get:nsjail.IdMap.use_newidmap)
  return _internal_use_newidmap();
}
inline void IdMap::_internal_set_use_newidmap(bool value) {
  _has_bits_[0] |= 0x00000004u;
  use_newidmap_ = value;
}
inline void IdMap::set_use_newidmap(bool value) {
  _internal_set_use_newidmap(value);
  // @@protoc_insertion_point(field_set:nsjail.IdMap.use_newidmap)
}

// -------------------------------------------------------------------

// MountPt

// optional string src = 1 [default = ""];
inline bool MountPt::_internal_has_src() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MountPt::has_src() const {
  return _internal_has_src();
}
inline void MountPt::clear_src() {
  src_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MountPt::src() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.src)
  return _internal_src();
}
inline void MountPt::set_src(const std::string& value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.src)
}
inline std::string* MountPt::mutable_src() {
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.src)
  return _internal_mutable_src();
}
inline const std::string& MountPt::_internal_src() const {
  return src_.Get();
}
inline void MountPt::_internal_set_src(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  src_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MountPt::set_src(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  src_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.src)
}
inline void MountPt::set_src(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  src_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.src)
}
inline void MountPt::set_src(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  src_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.src)
}
inline std::string* MountPt::_internal_mutable_src() {
  _has_bits_[0] |= 0x00000001u;
  return src_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MountPt::release_src() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.src)
  if (!_internal_has_src()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return src_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MountPt::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.src)
}

// optional string prefix_src_env = 2 [default = ""];
inline bool MountPt::_internal_has_prefix_src_env() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MountPt::has_prefix_src_env() const {
  return _internal_has_prefix_src_env();
}
inline void MountPt::clear_prefix_src_env() {
  prefix_src_env_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MountPt::prefix_src_env() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.prefix_src_env)
  return _internal_prefix_src_env();
}
inline void MountPt::set_prefix_src_env(const std::string& value) {
  _internal_set_prefix_src_env(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.prefix_src_env)
}
inline std::string* MountPt::mutable_prefix_src_env() {
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.prefix_src_env)
  return _internal_mutable_prefix_src_env();
}
inline const std::string& MountPt::_internal_prefix_src_env() const {
  return prefix_src_env_.Get();
}
inline void MountPt::_internal_set_prefix_src_env(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_src_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MountPt::set_prefix_src_env(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_src_env_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.prefix_src_env)
}
inline void MountPt::set_prefix_src_env(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  prefix_src_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.prefix_src_env)
}
inline void MountPt::set_prefix_src_env(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  prefix_src_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.prefix_src_env)
}
inline std::string* MountPt::_internal_mutable_prefix_src_env() {
  _has_bits_[0] |= 0x00000002u;
  return prefix_src_env_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MountPt::release_prefix_src_env() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.prefix_src_env)
  if (!_internal_has_prefix_src_env()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return prefix_src_env_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MountPt::set_allocated_prefix_src_env(std::string* prefix_src_env) {
  if (prefix_src_env != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prefix_src_env_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix_src_env,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.prefix_src_env)
}

// optional bytes src_content = 3 [default = ""];
inline bool MountPt::_internal_has_src_content() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MountPt::has_src_content() const {
  return _internal_has_src_content();
}
inline void MountPt::clear_src_content() {
  src_content_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MountPt::src_content() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.src_content)
  return _internal_src_content();
}
inline void MountPt::set_src_content(const std::string& value) {
  _internal_set_src_content(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.src_content)
}
inline std::string* MountPt::mutable_src_content() {
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.src_content)
  return _internal_mutable_src_content();
}
inline const std::string& MountPt::_internal_src_content() const {
  return src_content_.Get();
}
inline void MountPt::_internal_set_src_content(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  src_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MountPt::set_src_content(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  src_content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.src_content)
}
inline void MountPt::set_src_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  src_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.src_content)
}
inline void MountPt::set_src_content(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  src_content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.src_content)
}
inline std::string* MountPt::_internal_mutable_src_content() {
  _has_bits_[0] |= 0x00000004u;
  return src_content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MountPt::release_src_content() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.src_content)
  if (!_internal_has_src_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return src_content_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MountPt::set_allocated_src_content(std::string* src_content) {
  if (src_content != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  src_content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.src_content)
}

// required string dst = 4 [default = ""];
inline bool MountPt::_internal_has_dst() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MountPt::has_dst() const {
  return _internal_has_dst();
}
inline void MountPt::clear_dst() {
  dst_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MountPt::dst() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.dst)
  return _internal_dst();
}
inline void MountPt::set_dst(const std::string& value) {
  _internal_set_dst(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.dst)
}
inline std::string* MountPt::mutable_dst() {
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.dst)
  return _internal_mutable_dst();
}
inline const std::string& MountPt::_internal_dst() const {
  return dst_.Get();
}
inline void MountPt::_internal_set_dst(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  dst_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MountPt::set_dst(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  dst_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.dst)
}
inline void MountPt::set_dst(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  dst_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.dst)
}
inline void MountPt::set_dst(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  dst_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.dst)
}
inline std::string* MountPt::_internal_mutable_dst() {
  _has_bits_[0] |= 0x00000008u;
  return dst_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MountPt::release_dst() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.dst)
  if (!_internal_has_dst()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return dst_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MountPt::set_allocated_dst(std::string* dst) {
  if (dst != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dst_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dst,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.dst)
}

// optional string prefix_dst_env = 5 [default = ""];
inline bool MountPt::_internal_has_prefix_dst_env() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MountPt::has_prefix_dst_env() const {
  return _internal_has_prefix_dst_env();
}
inline void MountPt::clear_prefix_dst_env() {
  prefix_dst_env_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MountPt::prefix_dst_env() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.prefix_dst_env)
  return _internal_prefix_dst_env();
}
inline void MountPt::set_prefix_dst_env(const std::string& value) {
  _internal_set_prefix_dst_env(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.prefix_dst_env)
}
inline std::string* MountPt::mutable_prefix_dst_env() {
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.prefix_dst_env)
  return _internal_mutable_prefix_dst_env();
}
inline const std::string& MountPt::_internal_prefix_dst_env() const {
  return prefix_dst_env_.Get();
}
inline void MountPt::_internal_set_prefix_dst_env(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  prefix_dst_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MountPt::set_prefix_dst_env(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  prefix_dst_env_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.prefix_dst_env)
}
inline void MountPt::set_prefix_dst_env(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  prefix_dst_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.prefix_dst_env)
}
inline void MountPt::set_prefix_dst_env(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  prefix_dst_env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.prefix_dst_env)
}
inline std::string* MountPt::_internal_mutable_prefix_dst_env() {
  _has_bits_[0] |= 0x00000010u;
  return prefix_dst_env_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MountPt::release_prefix_dst_env() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.prefix_dst_env)
  if (!_internal_has_prefix_dst_env()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return prefix_dst_env_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MountPt::set_allocated_prefix_dst_env(std::string* prefix_dst_env) {
  if (prefix_dst_env != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  prefix_dst_env_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix_dst_env,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.prefix_dst_env)
}

// optional string fstype = 6 [default = ""];
inline bool MountPt::_internal_has_fstype() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MountPt::has_fstype() const {
  return _internal_has_fstype();
}
inline void MountPt::clear_fstype() {
  fstype_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MountPt::fstype() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.fstype)
  return _internal_fstype();
}
inline void MountPt::set_fstype(const std::string& value) {
  _internal_set_fstype(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.fstype)
}
inline std::string* MountPt::mutable_fstype() {
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.fstype)
  return _internal_mutable_fstype();
}
inline const std::string& MountPt::_internal_fstype() const {
  return fstype_.Get();
}
inline void MountPt::_internal_set_fstype(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  fstype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MountPt::set_fstype(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  fstype_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.fstype)
}
inline void MountPt::set_fstype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  fstype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.fstype)
}
inline void MountPt::set_fstype(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  fstype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.fstype)
}
inline std::string* MountPt::_internal_mutable_fstype() {
  _has_bits_[0] |= 0x00000020u;
  return fstype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MountPt::release_fstype() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.fstype)
  if (!_internal_has_fstype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return fstype_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MountPt::set_allocated_fstype(std::string* fstype) {
  if (fstype != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  fstype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fstype,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.fstype)
}

// optional string options = 7 [default = ""];
inline bool MountPt::_internal_has_options() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MountPt::has_options() const {
  return _internal_has_options();
}
inline void MountPt::clear_options() {
  options_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& MountPt::options() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.options)
  return _internal_options();
}
inline void MountPt::set_options(const std::string& value) {
  _internal_set_options(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.options)
}
inline std::string* MountPt::mutable_options() {
  // @@protoc_insertion_point(field_mutable:nsjail.MountPt.options)
  return _internal_mutable_options();
}
inline const std::string& MountPt::_internal_options() const {
  return options_.Get();
}
inline void MountPt::_internal_set_options(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  options_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MountPt::set_options(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  options_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.MountPt.options)
}
inline void MountPt::set_options(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  options_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.MountPt.options)
}
inline void MountPt::set_options(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  options_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.MountPt.options)
}
inline std::string* MountPt::_internal_mutable_options() {
  _has_bits_[0] |= 0x00000040u;
  return options_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MountPt::release_options() {
  // @@protoc_insertion_point(field_release:nsjail.MountPt.options)
  if (!_internal_has_options()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return options_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MountPt::set_allocated_options(std::string* options) {
  if (options != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  options_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), options,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.MountPt.options)
}

// optional bool is_bind = 8 [default = false];
inline bool MountPt::_internal_has_is_bind() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MountPt::has_is_bind() const {
  return _internal_has_is_bind();
}
inline void MountPt::clear_is_bind() {
  is_bind_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool MountPt::_internal_is_bind() const {
  return is_bind_;
}
inline bool MountPt::is_bind() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.is_bind)
  return _internal_is_bind();
}
inline void MountPt::_internal_set_is_bind(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_bind_ = value;
}
inline void MountPt::set_is_bind(bool value) {
  _internal_set_is_bind(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.is_bind)
}

// optional bool rw = 9 [default = false];
inline bool MountPt::_internal_has_rw() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MountPt::has_rw() const {
  return _internal_has_rw();
}
inline void MountPt::clear_rw() {
  rw_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool MountPt::_internal_rw() const {
  return rw_;
}
inline bool MountPt::rw() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.rw)
  return _internal_rw();
}
inline void MountPt::_internal_set_rw(bool value) {
  _has_bits_[0] |= 0x00000100u;
  rw_ = value;
}
inline void MountPt::set_rw(bool value) {
  _internal_set_rw(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.rw)
}

// optional bool is_dir = 10;
inline bool MountPt::_internal_has_is_dir() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MountPt::has_is_dir() const {
  return _internal_has_is_dir();
}
inline void MountPt::clear_is_dir() {
  is_dir_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool MountPt::_internal_is_dir() const {
  return is_dir_;
}
inline bool MountPt::is_dir() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.is_dir)
  return _internal_is_dir();
}
inline void MountPt::_internal_set_is_dir(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_dir_ = value;
}
inline void MountPt::set_is_dir(bool value) {
  _internal_set_is_dir(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.is_dir)
}

// optional bool mandatory = 11 [default = true];
inline bool MountPt::_internal_has_mandatory() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool MountPt::has_mandatory() const {
  return _internal_has_mandatory();
}
inline void MountPt::clear_mandatory() {
  mandatory_ = true;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool MountPt::_internal_mandatory() const {
  return mandatory_;
}
inline bool MountPt::mandatory() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.mandatory)
  return _internal_mandatory();
}
inline void MountPt::_internal_set_mandatory(bool value) {
  _has_bits_[0] |= 0x00004000u;
  mandatory_ = value;
}
inline void MountPt::set_mandatory(bool value) {
  _internal_set_mandatory(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.mandatory)
}

// optional bool is_symlink = 12 [default = false];
inline bool MountPt::_internal_has_is_symlink() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MountPt::has_is_symlink() const {
  return _internal_has_is_symlink();
}
inline void MountPt::clear_is_symlink() {
  is_symlink_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool MountPt::_internal_is_symlink() const {
  return is_symlink_;
}
inline bool MountPt::is_symlink() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.is_symlink)
  return _internal_is_symlink();
}
inline void MountPt::_internal_set_is_symlink(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_symlink_ = value;
}
inline void MountPt::set_is_symlink(bool value) {
  _internal_set_is_symlink(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.is_symlink)
}

// optional bool nosuid = 13 [default = false];
inline bool MountPt::_internal_has_nosuid() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MountPt::has_nosuid() const {
  return _internal_has_nosuid();
}
inline void MountPt::clear_nosuid() {
  nosuid_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool MountPt::_internal_nosuid() const {
  return nosuid_;
}
inline bool MountPt::nosuid() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.nosuid)
  return _internal_nosuid();
}
inline void MountPt::_internal_set_nosuid(bool value) {
  _has_bits_[0] |= 0x00000800u;
  nosuid_ = value;
}
inline void MountPt::set_nosuid(bool value) {
  _internal_set_nosuid(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.nosuid)
}

// optional bool nodev = 14 [default = false];
inline bool MountPt::_internal_has_nodev() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MountPt::has_nodev() const {
  return _internal_has_nodev();
}
inline void MountPt::clear_nodev() {
  nodev_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool MountPt::_internal_nodev() const {
  return nodev_;
}
inline bool MountPt::nodev() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.nodev)
  return _internal_nodev();
}
inline void MountPt::_internal_set_nodev(bool value) {
  _has_bits_[0] |= 0x00001000u;
  nodev_ = value;
}
inline void MountPt::set_nodev(bool value) {
  _internal_set_nodev(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.nodev)
}

// optional bool noexec = 15 [default = false];
inline bool MountPt::_internal_has_noexec() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MountPt::has_noexec() const {
  return _internal_has_noexec();
}
inline void MountPt::clear_noexec() {
  noexec_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool MountPt::_internal_noexec() const {
  return noexec_;
}
inline bool MountPt::noexec() const {
  // @@protoc_insertion_point(field_get:nsjail.MountPt.noexec)
  return _internal_noexec();
}
inline void MountPt::_internal_set_noexec(bool value) {
  _has_bits_[0] |= 0x00002000u;
  noexec_ = value;
}
inline void MountPt::set_noexec(bool value) {
  _internal_set_noexec(value);
  // @@protoc_insertion_point(field_set:nsjail.MountPt.noexec)
}

// -------------------------------------------------------------------

// Exe

// required string path = 1;
inline bool Exe::_internal_has_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Exe::has_path() const {
  return _internal_has_path();
}
inline void Exe::clear_path() {
  path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Exe::path() const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.path)
  return _internal_path();
}
inline void Exe::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:nsjail.Exe.path)
}
inline std::string* Exe::mutable_path() {
  // @@protoc_insertion_point(field_mutable:nsjail.Exe.path)
  return _internal_mutable_path();
}
inline const std::string& Exe::_internal_path() const {
  return path_.Get();
}
inline void Exe::_internal_set_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Exe::set_path(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.Exe.path)
}
inline void Exe::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.Exe.path)
}
inline void Exe::set_path(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.Exe.path)
}
inline std::string* Exe::_internal_mutable_path() {
  _has_bits_[0] |= 0x00000001u;
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Exe::release_path() {
  // @@protoc_insertion_point(field_release:nsjail.Exe.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Exe::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.Exe.path)
}

// repeated string arg = 2;
inline int Exe::_internal_arg_size() const {
  return arg_.size();
}
inline int Exe::arg_size() const {
  return _internal_arg_size();
}
inline void Exe::clear_arg() {
  arg_.Clear();
}
inline std::string* Exe::add_arg() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.Exe.arg)
  return _internal_add_arg();
}
inline const std::string& Exe::_internal_arg(int index) const {
  return arg_.Get(index);
}
inline const std::string& Exe::arg(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.arg)
  return _internal_arg(index);
}
inline std::string* Exe::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.Exe.arg)
  return arg_.Mutable(index);
}
inline void Exe::set_arg(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.Exe.arg)
  arg_.Mutable(index)->assign(value);
}
inline void Exe::set_arg(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.Exe.arg)
  arg_.Mutable(index)->assign(std::move(value));
}
inline void Exe::set_arg(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.Exe.arg)
}
inline void Exe::set_arg(int index, const char* value, size_t size) {
  arg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.Exe.arg)
}
inline std::string* Exe::_internal_add_arg() {
  return arg_.Add();
}
inline void Exe::add_arg(const std::string& value) {
  arg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.Exe.arg)
}
inline void Exe::add_arg(std::string&& value) {
  arg_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.Exe.arg)
}
inline void Exe::add_arg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.Exe.arg)
}
inline void Exe::add_arg(const char* value, size_t size) {
  arg_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.Exe.arg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Exe::arg() const {
  // @@protoc_insertion_point(field_list:nsjail.Exe.arg)
  return arg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Exe::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.Exe.arg)
  return &arg_;
}

// optional string arg0 = 3;
inline bool Exe::_internal_has_arg0() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Exe::has_arg0() const {
  return _internal_has_arg0();
}
inline void Exe::clear_arg0() {
  arg0_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Exe::arg0() const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.arg0)
  return _internal_arg0();
}
inline void Exe::set_arg0(const std::string& value) {
  _internal_set_arg0(value);
  // @@protoc_insertion_point(field_set:nsjail.Exe.arg0)
}
inline std::string* Exe::mutable_arg0() {
  // @@protoc_insertion_point(field_mutable:nsjail.Exe.arg0)
  return _internal_mutable_arg0();
}
inline const std::string& Exe::_internal_arg0() const {
  return arg0_.Get();
}
inline void Exe::_internal_set_arg0(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  arg0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Exe::set_arg0(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  arg0_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.Exe.arg0)
}
inline void Exe::set_arg0(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  arg0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.Exe.arg0)
}
inline void Exe::set_arg0(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  arg0_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.Exe.arg0)
}
inline std::string* Exe::_internal_mutable_arg0() {
  _has_bits_[0] |= 0x00000002u;
  return arg0_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Exe::release_arg0() {
  // @@protoc_insertion_point(field_release:nsjail.Exe.arg0)
  if (!_internal_has_arg0()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return arg0_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Exe::set_allocated_arg0(std::string* arg0) {
  if (arg0 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  arg0_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arg0,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.Exe.arg0)
}

// optional bool exec_fd = 4 [default = false];
inline bool Exe::_internal_has_exec_fd() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Exe::has_exec_fd() const {
  return _internal_has_exec_fd();
}
inline void Exe::clear_exec_fd() {
  exec_fd_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Exe::_internal_exec_fd() const {
  return exec_fd_;
}
inline bool Exe::exec_fd() const {
  // @@protoc_insertion_point(field_get:nsjail.Exe.exec_fd)
  return _internal_exec_fd();
}
inline void Exe::_internal_set_exec_fd(bool value) {
  _has_bits_[0] |= 0x00000004u;
  exec_fd_ = value;
}
inline void Exe::set_exec_fd(bool value) {
  _internal_set_exec_fd(value);
  // @@protoc_insertion_point(field_set:nsjail.Exe.exec_fd)
}

// -------------------------------------------------------------------

// NsJailConfig

// optional string name = 1 [default = ""];
inline bool NsJailConfig::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NsJailConfig::has_name() const {
  return _internal_has_name();
}
inline void NsJailConfig::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NsJailConfig::name() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.name)
  return _internal_name();
}
inline void NsJailConfig::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.name)
}
inline std::string* NsJailConfig::mutable_name() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.name)
  return _internal_mutable_name();
}
inline const std::string& NsJailConfig::_internal_name() const {
  return name_.Get();
}
inline void NsJailConfig::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.name)
}
inline void NsJailConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.name)
}
inline void NsJailConfig::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.name)
}
inline std::string* NsJailConfig::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NsJailConfig::release_name() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NsJailConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.name)
}

// repeated string description = 2;
inline int NsJailConfig::_internal_description_size() const {
  return description_.size();
}
inline int NsJailConfig::description_size() const {
  return _internal_description_size();
}
inline void NsJailConfig::clear_description() {
  description_.Clear();
}
inline std::string* NsJailConfig::add_description() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.description)
  return _internal_add_description();
}
inline const std::string& NsJailConfig::_internal_description(int index) const {
  return description_.Get(index);
}
inline const std::string& NsJailConfig::description(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.description)
  return _internal_description(index);
}
inline std::string* NsJailConfig::mutable_description(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.description)
  return description_.Mutable(index);
}
inline void NsJailConfig::set_description(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.description)
  description_.Mutable(index)->assign(value);
}
inline void NsJailConfig::set_description(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.description)
  description_.Mutable(index)->assign(std::move(value));
}
inline void NsJailConfig::set_description(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  description_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.description)
}
inline void NsJailConfig::set_description(int index, const char* value, size_t size) {
  description_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.description)
}
inline std::string* NsJailConfig::_internal_add_description() {
  return description_.Add();
}
inline void NsJailConfig::add_description(const std::string& value) {
  description_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.description)
}
inline void NsJailConfig::add_description(std::string&& value) {
  description_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.description)
}
inline void NsJailConfig::add_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  description_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.description)
}
inline void NsJailConfig::add_description(const char* value, size_t size) {
  description_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.description)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NsJailConfig::description() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.description)
  return description_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NsJailConfig::mutable_description() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.description)
  return &description_;
}

// optional .nsjail.Mode mode = 3 [default = ONCE];
inline bool NsJailConfig::_internal_has_mode() const {
  bool value = (_has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline bool NsJailConfig::has_mode() const {
  return _internal_has_mode();
}
inline void NsJailConfig::clear_mode() {
  mode_ = 1;
  _has_bits_[1] &= ~0x00400000u;
}
inline ::nsjail::Mode NsJailConfig::_internal_mode() const {
  return static_cast< ::nsjail::Mode >(mode_);
}
inline ::nsjail::Mode NsJailConfig::mode() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.mode)
  return _internal_mode();
}
inline void NsJailConfig::_internal_set_mode(::nsjail::Mode value) {
  assert(::nsjail::Mode_IsValid(value));
  _has_bits_[1] |= 0x00400000u;
  mode_ = value;
}
inline void NsJailConfig::set_mode(::nsjail::Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.mode)
}

// optional string hostname = 8 [default = "NSJAIL"];
inline bool NsJailConfig::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NsJailConfig::has_hostname() const {
  return _internal_has_hostname();
}
inline void NsJailConfig::clear_hostname() {
  hostname_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_, GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NsJailConfig::hostname() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.hostname)
  if (hostname_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_hostname_.get();
  return _internal_hostname();
}
inline void NsJailConfig::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.hostname)
}
inline std::string* NsJailConfig::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.hostname)
  return _internal_mutable_hostname();
}
inline const std::string& NsJailConfig::_internal_hostname() const {
  return hostname_.Get();
}
inline void NsJailConfig::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_hostname(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  hostname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.hostname)
}
inline void NsJailConfig::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.hostname)
}
inline void NsJailConfig::set_hostname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.hostname)
}
inline std::string* NsJailConfig::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000002u;
  return hostname_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_hostname_, GetArena());
}
inline std::string* NsJailConfig::release_hostname() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return hostname_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  hostname_.SetAllocated(nullptr, hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.hostname)
}

// optional string cwd = 9 [default = "/"];
inline bool NsJailConfig::_internal_has_cwd() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NsJailConfig::has_cwd() const {
  return _internal_has_cwd();
}
inline void NsJailConfig::clear_cwd() {
  cwd_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_, GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NsJailConfig::cwd() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cwd)
  if (cwd_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cwd_.get();
  return _internal_cwd();
}
inline void NsJailConfig::set_cwd(const std::string& value) {
  _internal_set_cwd(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cwd)
}
inline std::string* NsJailConfig::mutable_cwd() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cwd)
  return _internal_mutable_cwd();
}
inline const std::string& NsJailConfig::_internal_cwd() const {
  return cwd_.Get();
}
inline void NsJailConfig::_internal_set_cwd(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  cwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cwd(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  cwd_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cwd)
}
inline void NsJailConfig::set_cwd(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  cwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cwd)
}
inline void NsJailConfig::set_cwd(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  cwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cwd)
}
inline std::string* NsJailConfig::_internal_mutable_cwd() {
  _has_bits_[0] |= 0x00000004u;
  return cwd_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cwd_, GetArena());
}
inline std::string* NsJailConfig::release_cwd() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cwd)
  if (!_internal_has_cwd()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return cwd_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cwd(std::string* cwd) {
  if (cwd != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cwd_.SetAllocated(nullptr, cwd,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cwd)
}

// optional uint32 port = 10 [default = 0];
inline bool NsJailConfig::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool NsJailConfig::has_port() const {
  return _internal_has_port();
}
inline void NsJailConfig::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::port() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.port)
  return _internal_port();
}
inline void NsJailConfig::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  port_ = value;
}
inline void NsJailConfig::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.port)
}

// optional string bindhost = 11 [default = "::"];
inline bool NsJailConfig::_internal_has_bindhost() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NsJailConfig::has_bindhost() const {
  return _internal_has_bindhost();
}
inline void NsJailConfig::clear_bindhost() {
  bindhost_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_, GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NsJailConfig::bindhost() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.bindhost)
  if (bindhost_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_bindhost_.get();
  return _internal_bindhost();
}
inline void NsJailConfig::set_bindhost(const std::string& value) {
  _internal_set_bindhost(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.bindhost)
}
inline std::string* NsJailConfig::mutable_bindhost() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.bindhost)
  return _internal_mutable_bindhost();
}
inline const std::string& NsJailConfig::_internal_bindhost() const {
  return bindhost_.Get();
}
inline void NsJailConfig::_internal_set_bindhost(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  bindhost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_bindhost(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  bindhost_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.bindhost)
}
inline void NsJailConfig::set_bindhost(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  bindhost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.bindhost)
}
inline void NsJailConfig::set_bindhost(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  bindhost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.bindhost)
}
inline std::string* NsJailConfig::_internal_mutable_bindhost() {
  _has_bits_[0] |= 0x00000008u;
  return bindhost_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_bindhost_, GetArena());
}
inline std::string* NsJailConfig::release_bindhost() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.bindhost)
  if (!_internal_has_bindhost()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return bindhost_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_bindhost(std::string* bindhost) {
  if (bindhost != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  bindhost_.SetAllocated(nullptr, bindhost,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.bindhost)
}

// optional uint32 max_conns_per_ip = 12 [default = 0];
inline bool NsJailConfig::_internal_has_max_conns_per_ip() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool NsJailConfig::has_max_conns_per_ip() const {
  return _internal_has_max_conns_per_ip();
}
inline void NsJailConfig::clear_max_conns_per_ip() {
  max_conns_per_ip_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::_internal_max_conns_per_ip() const {
  return max_conns_per_ip_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::max_conns_per_ip() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.max_conns_per_ip)
  return _internal_max_conns_per_ip();
}
inline void NsJailConfig::_internal_set_max_conns_per_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00400000u;
  max_conns_per_ip_ = value;
}
inline void NsJailConfig::set_max_conns_per_ip(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_conns_per_ip(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.max_conns_per_ip)
}

// optional uint32 time_limit = 13 [default = 600];
inline bool NsJailConfig::_internal_has_time_limit() const {
  bool value = (_has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline bool NsJailConfig::has_time_limit() const {
  return _internal_has_time_limit();
}
inline void NsJailConfig::clear_time_limit() {
  time_limit_ = 600u;
  _has_bits_[1] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::_internal_time_limit() const {
  return time_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::time_limit() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.time_limit)
  return _internal_time_limit();
}
inline void NsJailConfig::_internal_set_time_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00800000u;
  time_limit_ = value;
}
inline void NsJailConfig::set_time_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time_limit(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.time_limit)
}

// optional bool daemon = 14 [default = false];
inline bool NsJailConfig::_internal_has_daemon() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_daemon() const {
  return _internal_has_daemon();
}
inline void NsJailConfig::clear_daemon() {
  daemon_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool NsJailConfig::_internal_daemon() const {
  return daemon_;
}
inline bool NsJailConfig::daemon() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.daemon)
  return _internal_daemon();
}
inline void NsJailConfig::_internal_set_daemon(bool value) {
  _has_bits_[0] |= 0x04000000u;
  daemon_ = value;
}
inline void NsJailConfig::set_daemon(bool value) {
  _internal_set_daemon(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.daemon)
}

// optional uint32 max_cpus = 15 [default = 0];
inline bool NsJailConfig::_internal_has_max_cpus() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool NsJailConfig::has_max_cpus() const {
  return _internal_has_max_cpus();
}
inline void NsJailConfig::clear_max_cpus() {
  max_cpus_ = 0u;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::_internal_max_cpus() const {
  return max_cpus_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::max_cpus() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.max_cpus)
  return _internal_max_cpus();
}
inline void NsJailConfig::_internal_set_max_cpus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00800000u;
  max_cpus_ = value;
}
inline void NsJailConfig::set_max_cpus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_cpus(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.max_cpus)
}

// optional int32 log_fd = 16;
inline bool NsJailConfig::_internal_has_log_fd() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_log_fd() const {
  return _internal_has_log_fd();
}
inline void NsJailConfig::clear_log_fd() {
  log_fd_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NsJailConfig::_internal_log_fd() const {
  return log_fd_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NsJailConfig::log_fd() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.log_fd)
  return _internal_log_fd();
}
inline void NsJailConfig::_internal_set_log_fd(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x01000000u;
  log_fd_ = value;
}
inline void NsJailConfig::set_log_fd(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_log_fd(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.log_fd)
}

// optional string log_file = 17;
inline bool NsJailConfig::_internal_has_log_file() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NsJailConfig::has_log_file() const {
  return _internal_has_log_file();
}
inline void NsJailConfig::clear_log_file() {
  log_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& NsJailConfig::log_file() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.log_file)
  return _internal_log_file();
}
inline void NsJailConfig::set_log_file(const std::string& value) {
  _internal_set_log_file(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.log_file)
}
inline std::string* NsJailConfig::mutable_log_file() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.log_file)
  return _internal_mutable_log_file();
}
inline const std::string& NsJailConfig::_internal_log_file() const {
  return log_file_.Get();
}
inline void NsJailConfig::_internal_set_log_file(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  log_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_log_file(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  log_file_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.log_file)
}
inline void NsJailConfig::set_log_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  log_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.log_file)
}
inline void NsJailConfig::set_log_file(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  log_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.log_file)
}
inline std::string* NsJailConfig::_internal_mutable_log_file() {
  _has_bits_[0] |= 0x00000010u;
  return log_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NsJailConfig::release_log_file() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.log_file)
  if (!_internal_has_log_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return log_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NsJailConfig::set_allocated_log_file(std::string* log_file) {
  if (log_file != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  log_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log_file,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.log_file)
}

// optional .nsjail.LogLevel log_level = 18;
inline bool NsJailConfig::_internal_has_log_level() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_log_level() const {
  return _internal_has_log_level();
}
inline void NsJailConfig::clear_log_level() {
  log_level_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::nsjail::LogLevel NsJailConfig::_internal_log_level() const {
  return static_cast< ::nsjail::LogLevel >(log_level_);
}
inline ::nsjail::LogLevel NsJailConfig::log_level() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.log_level)
  return _internal_log_level();
}
inline void NsJailConfig::_internal_set_log_level(::nsjail::LogLevel value) {
  assert(::nsjail::LogLevel_IsValid(value));
  _has_bits_[0] |= 0x02000000u;
  log_level_ = value;
}
inline void NsJailConfig::set_log_level(::nsjail::LogLevel value) {
  _internal_set_log_level(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.log_level)
}

// optional bool keep_env = 19 [default = false];
inline bool NsJailConfig::_internal_has_keep_env() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_keep_env() const {
  return _internal_has_keep_env();
}
inline void NsJailConfig::clear_keep_env() {
  keep_env_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool NsJailConfig::_internal_keep_env() const {
  return keep_env_;
}
inline bool NsJailConfig::keep_env() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.keep_env)
  return _internal_keep_env();
}
inline void NsJailConfig::_internal_set_keep_env(bool value) {
  _has_bits_[0] |= 0x08000000u;
  keep_env_ = value;
}
inline void NsJailConfig::set_keep_env(bool value) {
  _internal_set_keep_env(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.keep_env)
}

// repeated string envar = 20;
inline int NsJailConfig::_internal_envar_size() const {
  return envar_.size();
}
inline int NsJailConfig::envar_size() const {
  return _internal_envar_size();
}
inline void NsJailConfig::clear_envar() {
  envar_.Clear();
}
inline std::string* NsJailConfig::add_envar() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.envar)
  return _internal_add_envar();
}
inline const std::string& NsJailConfig::_internal_envar(int index) const {
  return envar_.Get(index);
}
inline const std::string& NsJailConfig::envar(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.envar)
  return _internal_envar(index);
}
inline std::string* NsJailConfig::mutable_envar(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.envar)
  return envar_.Mutable(index);
}
inline void NsJailConfig::set_envar(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.envar)
  envar_.Mutable(index)->assign(value);
}
inline void NsJailConfig::set_envar(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.envar)
  envar_.Mutable(index)->assign(std::move(value));
}
inline void NsJailConfig::set_envar(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  envar_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.envar)
}
inline void NsJailConfig::set_envar(int index, const char* value, size_t size) {
  envar_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.envar)
}
inline std::string* NsJailConfig::_internal_add_envar() {
  return envar_.Add();
}
inline void NsJailConfig::add_envar(const std::string& value) {
  envar_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.envar)
}
inline void NsJailConfig::add_envar(std::string&& value) {
  envar_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.envar)
}
inline void NsJailConfig::add_envar(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  envar_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.envar)
}
inline void NsJailConfig::add_envar(const char* value, size_t size) {
  envar_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.envar)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NsJailConfig::envar() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.envar)
  return envar_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NsJailConfig::mutable_envar() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.envar)
  return &envar_;
}

// optional bool keep_caps = 21 [default = false];
inline bool NsJailConfig::_internal_has_keep_caps() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_keep_caps() const {
  return _internal_has_keep_caps();
}
inline void NsJailConfig::clear_keep_caps() {
  keep_caps_ = false;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool NsJailConfig::_internal_keep_caps() const {
  return keep_caps_;
}
inline bool NsJailConfig::keep_caps() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.keep_caps)
  return _internal_keep_caps();
}
inline void NsJailConfig::_internal_set_keep_caps(bool value) {
  _has_bits_[0] |= 0x10000000u;
  keep_caps_ = value;
}
inline void NsJailConfig::set_keep_caps(bool value) {
  _internal_set_keep_caps(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.keep_caps)
}

// repeated string cap = 22;
inline int NsJailConfig::_internal_cap_size() const {
  return cap_.size();
}
inline int NsJailConfig::cap_size() const {
  return _internal_cap_size();
}
inline void NsJailConfig::clear_cap() {
  cap_.Clear();
}
inline std::string* NsJailConfig::add_cap() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.cap)
  return _internal_add_cap();
}
inline const std::string& NsJailConfig::_internal_cap(int index) const {
  return cap_.Get(index);
}
inline const std::string& NsJailConfig::cap(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cap)
  return _internal_cap(index);
}
inline std::string* NsJailConfig::mutable_cap(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cap)
  return cap_.Mutable(index);
}
inline void NsJailConfig::set_cap(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cap)
  cap_.Mutable(index)->assign(value);
}
inline void NsJailConfig::set_cap(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cap)
  cap_.Mutable(index)->assign(std::move(value));
}
inline void NsJailConfig::set_cap(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cap)
}
inline void NsJailConfig::set_cap(int index, const char* value, size_t size) {
  cap_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cap)
}
inline std::string* NsJailConfig::_internal_add_cap() {
  return cap_.Add();
}
inline void NsJailConfig::add_cap(const std::string& value) {
  cap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.cap)
}
inline void NsJailConfig::add_cap(std::string&& value) {
  cap_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.cap)
}
inline void NsJailConfig::add_cap(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  cap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.cap)
}
inline void NsJailConfig::add_cap(const char* value, size_t size) {
  cap_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.cap)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NsJailConfig::cap() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.cap)
  return cap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NsJailConfig::mutable_cap() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.cap)
  return &cap_;
}

// optional bool silent = 23 [default = false];
inline bool NsJailConfig::_internal_has_silent() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_silent() const {
  return _internal_has_silent();
}
inline void NsJailConfig::clear_silent() {
  silent_ = false;
  _has_bits_[0] &= ~0x20000000u;
}
inline bool NsJailConfig::_internal_silent() const {
  return silent_;
}
inline bool NsJailConfig::silent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.silent)
  return _internal_silent();
}
inline void NsJailConfig::_internal_set_silent(bool value) {
  _has_bits_[0] |= 0x20000000u;
  silent_ = value;
}
inline void NsJailConfig::set_silent(bool value) {
  _internal_set_silent(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.silent)
}

// optional bool skip_setsid = 24 [default = false];
inline bool NsJailConfig::_internal_has_skip_setsid() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool NsJailConfig::has_skip_setsid() const {
  return _internal_has_skip_setsid();
}
inline void NsJailConfig::clear_skip_setsid() {
  skip_setsid_ = false;
  _has_bits_[1] &= ~0x00000010u;
}
inline bool NsJailConfig::_internal_skip_setsid() const {
  return skip_setsid_;
}
inline bool NsJailConfig::skip_setsid() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.skip_setsid)
  return _internal_skip_setsid();
}
inline void NsJailConfig::_internal_set_skip_setsid(bool value) {
  _has_bits_[1] |= 0x00000010u;
  skip_setsid_ = value;
}
inline void NsJailConfig::set_skip_setsid(bool value) {
  _internal_set_skip_setsid(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.skip_setsid)
}

// optional bool stderr_to_null = 25 [default = false];
inline bool NsJailConfig::_internal_has_stderr_to_null() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool NsJailConfig::has_stderr_to_null() const {
  return _internal_has_stderr_to_null();
}
inline void NsJailConfig::clear_stderr_to_null() {
  stderr_to_null_ = false;
  _has_bits_[1] &= ~0x00000020u;
}
inline bool NsJailConfig::_internal_stderr_to_null() const {
  return stderr_to_null_;
}
inline bool NsJailConfig::stderr_to_null() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.stderr_to_null)
  return _internal_stderr_to_null();
}
inline void NsJailConfig::_internal_set_stderr_to_null(bool value) {
  _has_bits_[1] |= 0x00000020u;
  stderr_to_null_ = value;
}
inline void NsJailConfig::set_stderr_to_null(bool value) {
  _internal_set_stderr_to_null(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.stderr_to_null)
}

// repeated int32 pass_fd = 26;
inline int NsJailConfig::_internal_pass_fd_size() const {
  return pass_fd_.size();
}
inline int NsJailConfig::pass_fd_size() const {
  return _internal_pass_fd_size();
}
inline void NsJailConfig::clear_pass_fd() {
  pass_fd_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NsJailConfig::_internal_pass_fd(int index) const {
  return pass_fd_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NsJailConfig::pass_fd(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.pass_fd)
  return _internal_pass_fd(index);
}
inline void NsJailConfig::set_pass_fd(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  pass_fd_.Set(index, value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.pass_fd)
}
inline void NsJailConfig::_internal_add_pass_fd(::PROTOBUF_NAMESPACE_ID::int32 value) {
  pass_fd_.Add(value);
}
inline void NsJailConfig::add_pass_fd(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_pass_fd(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.pass_fd)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
NsJailConfig::_internal_pass_fd() const {
  return pass_fd_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
NsJailConfig::pass_fd() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.pass_fd)
  return _internal_pass_fd();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
NsJailConfig::_internal_mutable_pass_fd() {
  return &pass_fd_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
NsJailConfig::mutable_pass_fd() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.pass_fd)
  return _internal_mutable_pass_fd();
}

// optional bool disable_no_new_privs = 27 [default = false];
inline bool NsJailConfig::_internal_has_disable_no_new_privs() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool NsJailConfig::has_disable_no_new_privs() const {
  return _internal_has_disable_no_new_privs();
}
inline void NsJailConfig::clear_disable_no_new_privs() {
  disable_no_new_privs_ = false;
  _has_bits_[1] &= ~0x00000040u;
}
inline bool NsJailConfig::_internal_disable_no_new_privs() const {
  return disable_no_new_privs_;
}
inline bool NsJailConfig::disable_no_new_privs() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.disable_no_new_privs)
  return _internal_disable_no_new_privs();
}
inline void NsJailConfig::_internal_set_disable_no_new_privs(bool value) {
  _has_bits_[1] |= 0x00000040u;
  disable_no_new_privs_ = value;
}
inline void NsJailConfig::set_disable_no_new_privs(bool value) {
  _internal_set_disable_no_new_privs(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.disable_no_new_privs)
}

// optional uint64 rlimit_as = 28 [default = 4096];
inline bool NsJailConfig::_internal_has_rlimit_as() const {
  bool value = (_has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_as() const {
  return _internal_has_rlimit_as();
}
inline void NsJailConfig::clear_rlimit_as() {
  rlimit_as_ = PROTOBUF_ULONGLONG(4096);
  _has_bits_[1] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_rlimit_as() const {
  return rlimit_as_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::rlimit_as() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_as)
  return _internal_rlimit_as();
}
inline void NsJailConfig::_internal_set_rlimit_as(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x01000000u;
  rlimit_as_ = value;
}
inline void NsJailConfig::set_rlimit_as(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rlimit_as(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_as)
}

// optional .nsjail.RLimit rlimit_as_type = 29 [default = VALUE];
inline bool NsJailConfig::_internal_has_rlimit_as_type() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_as_type() const {
  return _internal_has_rlimit_as_type();
}
inline void NsJailConfig::clear_rlimit_as_type() {
  rlimit_as_type_ = 0;
  _has_bits_[0] &= ~0x80000000u;
}
inline ::nsjail::RLimit NsJailConfig::_internal_rlimit_as_type() const {
  return static_cast< ::nsjail::RLimit >(rlimit_as_type_);
}
inline ::nsjail::RLimit NsJailConfig::rlimit_as_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_as_type)
  return _internal_rlimit_as_type();
}
inline void NsJailConfig::_internal_set_rlimit_as_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  _has_bits_[0] |= 0x80000000u;
  rlimit_as_type_ = value;
}
inline void NsJailConfig::set_rlimit_as_type(::nsjail::RLimit value) {
  _internal_set_rlimit_as_type(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_as_type)
}

// optional uint64 rlimit_core = 30 [default = 0];
inline bool NsJailConfig::_internal_has_rlimit_core() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_core() const {
  return _internal_has_rlimit_core();
}
inline void NsJailConfig::clear_rlimit_core() {
  rlimit_core_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x40000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_rlimit_core() const {
  return rlimit_core_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::rlimit_core() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_core)
  return _internal_rlimit_core();
}
inline void NsJailConfig::_internal_set_rlimit_core(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x40000000u;
  rlimit_core_ = value;
}
inline void NsJailConfig::set_rlimit_core(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rlimit_core(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_core)
}

// optional .nsjail.RLimit rlimit_core_type = 31 [default = VALUE];
inline bool NsJailConfig::_internal_has_rlimit_core_type() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_core_type() const {
  return _internal_has_rlimit_core_type();
}
inline void NsJailConfig::clear_rlimit_core_type() {
  rlimit_core_type_ = 0;
  _has_bits_[1] &= ~0x00000001u;
}
inline ::nsjail::RLimit NsJailConfig::_internal_rlimit_core_type() const {
  return static_cast< ::nsjail::RLimit >(rlimit_core_type_);
}
inline ::nsjail::RLimit NsJailConfig::rlimit_core_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_core_type)
  return _internal_rlimit_core_type();
}
inline void NsJailConfig::_internal_set_rlimit_core_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  _has_bits_[1] |= 0x00000001u;
  rlimit_core_type_ = value;
}
inline void NsJailConfig::set_rlimit_core_type(::nsjail::RLimit value) {
  _internal_set_rlimit_core_type(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_core_type)
}

// optional uint64 rlimit_cpu = 32 [default = 600];
inline bool NsJailConfig::_internal_has_rlimit_cpu() const {
  bool value = (_has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_cpu() const {
  return _internal_has_rlimit_cpu();
}
inline void NsJailConfig::clear_rlimit_cpu() {
  rlimit_cpu_ = PROTOBUF_ULONGLONG(600);
  _has_bits_[1] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_rlimit_cpu() const {
  return rlimit_cpu_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::rlimit_cpu() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_cpu)
  return _internal_rlimit_cpu();
}
inline void NsJailConfig::_internal_set_rlimit_cpu(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x02000000u;
  rlimit_cpu_ = value;
}
inline void NsJailConfig::set_rlimit_cpu(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rlimit_cpu(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_cpu)
}

// optional .nsjail.RLimit rlimit_cpu_type = 33 [default = VALUE];
inline bool NsJailConfig::_internal_has_rlimit_cpu_type() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_cpu_type() const {
  return _internal_has_rlimit_cpu_type();
}
inline void NsJailConfig::clear_rlimit_cpu_type() {
  rlimit_cpu_type_ = 0;
  _has_bits_[1] &= ~0x00000002u;
}
inline ::nsjail::RLimit NsJailConfig::_internal_rlimit_cpu_type() const {
  return static_cast< ::nsjail::RLimit >(rlimit_cpu_type_);
}
inline ::nsjail::RLimit NsJailConfig::rlimit_cpu_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_cpu_type)
  return _internal_rlimit_cpu_type();
}
inline void NsJailConfig::_internal_set_rlimit_cpu_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  _has_bits_[1] |= 0x00000002u;
  rlimit_cpu_type_ = value;
}
inline void NsJailConfig::set_rlimit_cpu_type(::nsjail::RLimit value) {
  _internal_set_rlimit_cpu_type(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_cpu_type)
}

// optional uint64 rlimit_fsize = 34 [default = 1];
inline bool NsJailConfig::_internal_has_rlimit_fsize() const {
  bool value = (_has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_fsize() const {
  return _internal_has_rlimit_fsize();
}
inline void NsJailConfig::clear_rlimit_fsize() {
  rlimit_fsize_ = PROTOBUF_ULONGLONG(1);
  _has_bits_[1] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_rlimit_fsize() const {
  return rlimit_fsize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::rlimit_fsize() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_fsize)
  return _internal_rlimit_fsize();
}
inline void NsJailConfig::_internal_set_rlimit_fsize(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x04000000u;
  rlimit_fsize_ = value;
}
inline void NsJailConfig::set_rlimit_fsize(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rlimit_fsize(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_fsize)
}

// optional .nsjail.RLimit rlimit_fsize_type = 35 [default = VALUE];
inline bool NsJailConfig::_internal_has_rlimit_fsize_type() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_fsize_type() const {
  return _internal_has_rlimit_fsize_type();
}
inline void NsJailConfig::clear_rlimit_fsize_type() {
  rlimit_fsize_type_ = 0;
  _has_bits_[1] &= ~0x00000004u;
}
inline ::nsjail::RLimit NsJailConfig::_internal_rlimit_fsize_type() const {
  return static_cast< ::nsjail::RLimit >(rlimit_fsize_type_);
}
inline ::nsjail::RLimit NsJailConfig::rlimit_fsize_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_fsize_type)
  return _internal_rlimit_fsize_type();
}
inline void NsJailConfig::_internal_set_rlimit_fsize_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  _has_bits_[1] |= 0x00000004u;
  rlimit_fsize_type_ = value;
}
inline void NsJailConfig::set_rlimit_fsize_type(::nsjail::RLimit value) {
  _internal_set_rlimit_fsize_type(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_fsize_type)
}

// optional uint64 rlimit_nofile = 36 [default = 32];
inline bool NsJailConfig::_internal_has_rlimit_nofile() const {
  bool value = (_has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_nofile() const {
  return _internal_has_rlimit_nofile();
}
inline void NsJailConfig::clear_rlimit_nofile() {
  rlimit_nofile_ = PROTOBUF_ULONGLONG(32);
  _has_bits_[1] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_rlimit_nofile() const {
  return rlimit_nofile_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::rlimit_nofile() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nofile)
  return _internal_rlimit_nofile();
}
inline void NsJailConfig::_internal_set_rlimit_nofile(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x08000000u;
  rlimit_nofile_ = value;
}
inline void NsJailConfig::set_rlimit_nofile(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rlimit_nofile(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nofile)
}

// optional .nsjail.RLimit rlimit_nofile_type = 37 [default = VALUE];
inline bool NsJailConfig::_internal_has_rlimit_nofile_type() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_nofile_type() const {
  return _internal_has_rlimit_nofile_type();
}
inline void NsJailConfig::clear_rlimit_nofile_type() {
  rlimit_nofile_type_ = 0;
  _has_bits_[1] &= ~0x00000008u;
}
inline ::nsjail::RLimit NsJailConfig::_internal_rlimit_nofile_type() const {
  return static_cast< ::nsjail::RLimit >(rlimit_nofile_type_);
}
inline ::nsjail::RLimit NsJailConfig::rlimit_nofile_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nofile_type)
  return _internal_rlimit_nofile_type();
}
inline void NsJailConfig::_internal_set_rlimit_nofile_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  _has_bits_[1] |= 0x00000008u;
  rlimit_nofile_type_ = value;
}
inline void NsJailConfig::set_rlimit_nofile_type(::nsjail::RLimit value) {
  _internal_set_rlimit_nofile_type(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nofile_type)
}

// optional uint64 rlimit_nproc = 38 [default = 1024];
inline bool NsJailConfig::_internal_has_rlimit_nproc() const {
  bool value = (_has_bits_[1] & 0x10000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_nproc() const {
  return _internal_has_rlimit_nproc();
}
inline void NsJailConfig::clear_rlimit_nproc() {
  rlimit_nproc_ = PROTOBUF_ULONGLONG(1024);
  _has_bits_[1] &= ~0x10000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_rlimit_nproc() const {
  return rlimit_nproc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::rlimit_nproc() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nproc)
  return _internal_rlimit_nproc();
}
inline void NsJailConfig::_internal_set_rlimit_nproc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x10000000u;
  rlimit_nproc_ = value;
}
inline void NsJailConfig::set_rlimit_nproc(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rlimit_nproc(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nproc)
}

// optional .nsjail.RLimit rlimit_nproc_type = 39 [default = SOFT];
inline bool NsJailConfig::_internal_has_rlimit_nproc_type() const {
  bool value = (_has_bits_[1] & 0x40000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_nproc_type() const {
  return _internal_has_rlimit_nproc_type();
}
inline void NsJailConfig::clear_rlimit_nproc_type() {
  rlimit_nproc_type_ = 1;
  _has_bits_[1] &= ~0x40000000u;
}
inline ::nsjail::RLimit NsJailConfig::_internal_rlimit_nproc_type() const {
  return static_cast< ::nsjail::RLimit >(rlimit_nproc_type_);
}
inline ::nsjail::RLimit NsJailConfig::rlimit_nproc_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_nproc_type)
  return _internal_rlimit_nproc_type();
}
inline void NsJailConfig::_internal_set_rlimit_nproc_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  _has_bits_[1] |= 0x40000000u;
  rlimit_nproc_type_ = value;
}
inline void NsJailConfig::set_rlimit_nproc_type(::nsjail::RLimit value) {
  _internal_set_rlimit_nproc_type(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_nproc_type)
}

// optional uint64 rlimit_stack = 40 [default = 8];
inline bool NsJailConfig::_internal_has_rlimit_stack() const {
  bool value = (_has_bits_[1] & 0x20000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_stack() const {
  return _internal_has_rlimit_stack();
}
inline void NsJailConfig::clear_rlimit_stack() {
  rlimit_stack_ = PROTOBUF_ULONGLONG(8);
  _has_bits_[1] &= ~0x20000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_rlimit_stack() const {
  return rlimit_stack_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::rlimit_stack() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_stack)
  return _internal_rlimit_stack();
}
inline void NsJailConfig::_internal_set_rlimit_stack(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x20000000u;
  rlimit_stack_ = value;
}
inline void NsJailConfig::set_rlimit_stack(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rlimit_stack(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_stack)
}

// optional .nsjail.RLimit rlimit_stack_type = 41 [default = SOFT];
inline bool NsJailConfig::_internal_has_rlimit_stack_type() const {
  bool value = (_has_bits_[1] & 0x80000000u) != 0;
  return value;
}
inline bool NsJailConfig::has_rlimit_stack_type() const {
  return _internal_has_rlimit_stack_type();
}
inline void NsJailConfig::clear_rlimit_stack_type() {
  rlimit_stack_type_ = 1;
  _has_bits_[1] &= ~0x80000000u;
}
inline ::nsjail::RLimit NsJailConfig::_internal_rlimit_stack_type() const {
  return static_cast< ::nsjail::RLimit >(rlimit_stack_type_);
}
inline ::nsjail::RLimit NsJailConfig::rlimit_stack_type() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.rlimit_stack_type)
  return _internal_rlimit_stack_type();
}
inline void NsJailConfig::_internal_set_rlimit_stack_type(::nsjail::RLimit value) {
  assert(::nsjail::RLimit_IsValid(value));
  _has_bits_[1] |= 0x80000000u;
  rlimit_stack_type_ = value;
}
inline void NsJailConfig::set_rlimit_stack_type(::nsjail::RLimit value) {
  _internal_set_rlimit_stack_type(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.rlimit_stack_type)
}

// optional bool disable_rl = 84 [default = false];
inline bool NsJailConfig::_internal_has_disable_rl() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool NsJailConfig::has_disable_rl() const {
  return _internal_has_disable_rl();
}
inline void NsJailConfig::clear_disable_rl() {
  disable_rl_ = false;
  _has_bits_[1] &= ~0x00000080u;
}
inline bool NsJailConfig::_internal_disable_rl() const {
  return disable_rl_;
}
inline bool NsJailConfig::disable_rl() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.disable_rl)
  return _internal_disable_rl();
}
inline void NsJailConfig::_internal_set_disable_rl(bool value) {
  _has_bits_[1] |= 0x00000080u;
  disable_rl_ = value;
}
inline void NsJailConfig::set_disable_rl(bool value) {
  _internal_set_disable_rl(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.disable_rl)
}

// optional bool persona_addr_compat_layout = 42 [default = false];
inline bool NsJailConfig::_internal_has_persona_addr_compat_layout() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool NsJailConfig::has_persona_addr_compat_layout() const {
  return _internal_has_persona_addr_compat_layout();
}
inline void NsJailConfig::clear_persona_addr_compat_layout() {
  persona_addr_compat_layout_ = false;
  _has_bits_[1] &= ~0x00000100u;
}
inline bool NsJailConfig::_internal_persona_addr_compat_layout() const {
  return persona_addr_compat_layout_;
}
inline bool NsJailConfig::persona_addr_compat_layout() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_addr_compat_layout)
  return _internal_persona_addr_compat_layout();
}
inline void NsJailConfig::_internal_set_persona_addr_compat_layout(bool value) {
  _has_bits_[1] |= 0x00000100u;
  persona_addr_compat_layout_ = value;
}
inline void NsJailConfig::set_persona_addr_compat_layout(bool value) {
  _internal_set_persona_addr_compat_layout(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_addr_compat_layout)
}

// optional bool persona_mmap_page_zero = 43 [default = false];
inline bool NsJailConfig::_internal_has_persona_mmap_page_zero() const {
  bool value = (_has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool NsJailConfig::has_persona_mmap_page_zero() const {
  return _internal_has_persona_mmap_page_zero();
}
inline void NsJailConfig::clear_persona_mmap_page_zero() {
  persona_mmap_page_zero_ = false;
  _has_bits_[1] &= ~0x00000200u;
}
inline bool NsJailConfig::_internal_persona_mmap_page_zero() const {
  return persona_mmap_page_zero_;
}
inline bool NsJailConfig::persona_mmap_page_zero() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_mmap_page_zero)
  return _internal_persona_mmap_page_zero();
}
inline void NsJailConfig::_internal_set_persona_mmap_page_zero(bool value) {
  _has_bits_[1] |= 0x00000200u;
  persona_mmap_page_zero_ = value;
}
inline void NsJailConfig::set_persona_mmap_page_zero(bool value) {
  _internal_set_persona_mmap_page_zero(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_mmap_page_zero)
}

// optional bool persona_read_implies_exec = 44 [default = false];
inline bool NsJailConfig::_internal_has_persona_read_implies_exec() const {
  bool value = (_has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool NsJailConfig::has_persona_read_implies_exec() const {
  return _internal_has_persona_read_implies_exec();
}
inline void NsJailConfig::clear_persona_read_implies_exec() {
  persona_read_implies_exec_ = false;
  _has_bits_[1] &= ~0x00000400u;
}
inline bool NsJailConfig::_internal_persona_read_implies_exec() const {
  return persona_read_implies_exec_;
}
inline bool NsJailConfig::persona_read_implies_exec() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_read_implies_exec)
  return _internal_persona_read_implies_exec();
}
inline void NsJailConfig::_internal_set_persona_read_implies_exec(bool value) {
  _has_bits_[1] |= 0x00000400u;
  persona_read_implies_exec_ = value;
}
inline void NsJailConfig::set_persona_read_implies_exec(bool value) {
  _internal_set_persona_read_implies_exec(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_read_implies_exec)
}

// optional bool persona_addr_limit_3gb = 45 [default = false];
inline bool NsJailConfig::_internal_has_persona_addr_limit_3gb() const {
  bool value = (_has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool NsJailConfig::has_persona_addr_limit_3gb() const {
  return _internal_has_persona_addr_limit_3gb();
}
inline void NsJailConfig::clear_persona_addr_limit_3gb() {
  persona_addr_limit_3gb_ = false;
  _has_bits_[1] &= ~0x00000800u;
}
inline bool NsJailConfig::_internal_persona_addr_limit_3gb() const {
  return persona_addr_limit_3gb_;
}
inline bool NsJailConfig::persona_addr_limit_3gb() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_addr_limit_3gb)
  return _internal_persona_addr_limit_3gb();
}
inline void NsJailConfig::_internal_set_persona_addr_limit_3gb(bool value) {
  _has_bits_[1] |= 0x00000800u;
  persona_addr_limit_3gb_ = value;
}
inline void NsJailConfig::set_persona_addr_limit_3gb(bool value) {
  _internal_set_persona_addr_limit_3gb(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_addr_limit_3gb)
}

// optional bool persona_addr_no_randomize = 46 [default = false];
inline bool NsJailConfig::_internal_has_persona_addr_no_randomize() const {
  bool value = (_has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool NsJailConfig::has_persona_addr_no_randomize() const {
  return _internal_has_persona_addr_no_randomize();
}
inline void NsJailConfig::clear_persona_addr_no_randomize() {
  persona_addr_no_randomize_ = false;
  _has_bits_[1] &= ~0x00001000u;
}
inline bool NsJailConfig::_internal_persona_addr_no_randomize() const {
  return persona_addr_no_randomize_;
}
inline bool NsJailConfig::persona_addr_no_randomize() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.persona_addr_no_randomize)
  return _internal_persona_addr_no_randomize();
}
inline void NsJailConfig::_internal_set_persona_addr_no_randomize(bool value) {
  _has_bits_[1] |= 0x00001000u;
  persona_addr_no_randomize_ = value;
}
inline void NsJailConfig::set_persona_addr_no_randomize(bool value) {
  _internal_set_persona_addr_no_randomize(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.persona_addr_no_randomize)
}

// optional bool clone_newnet = 47 [default = true];
inline bool NsJailConfig::_internal_has_clone_newnet() const {
  bool value = (_has_bits_[2] & 0x00000001u) != 0;
  return value;
}
inline bool NsJailConfig::has_clone_newnet() const {
  return _internal_has_clone_newnet();
}
inline void NsJailConfig::clear_clone_newnet() {
  clone_newnet_ = true;
  _has_bits_[2] &= ~0x00000001u;
}
inline bool NsJailConfig::_internal_clone_newnet() const {
  return clone_newnet_;
}
inline bool NsJailConfig::clone_newnet() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newnet)
  return _internal_clone_newnet();
}
inline void NsJailConfig::_internal_set_clone_newnet(bool value) {
  _has_bits_[2] |= 0x00000001u;
  clone_newnet_ = value;
}
inline void NsJailConfig::set_clone_newnet(bool value) {
  _internal_set_clone_newnet(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newnet)
}

// optional bool clone_newuser = 48 [default = true];
inline bool NsJailConfig::_internal_has_clone_newuser() const {
  bool value = (_has_bits_[2] & 0x00000002u) != 0;
  return value;
}
inline bool NsJailConfig::has_clone_newuser() const {
  return _internal_has_clone_newuser();
}
inline void NsJailConfig::clear_clone_newuser() {
  clone_newuser_ = true;
  _has_bits_[2] &= ~0x00000002u;
}
inline bool NsJailConfig::_internal_clone_newuser() const {
  return clone_newuser_;
}
inline bool NsJailConfig::clone_newuser() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newuser)
  return _internal_clone_newuser();
}
inline void NsJailConfig::_internal_set_clone_newuser(bool value) {
  _has_bits_[2] |= 0x00000002u;
  clone_newuser_ = value;
}
inline void NsJailConfig::set_clone_newuser(bool value) {
  _internal_set_clone_newuser(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newuser)
}

// optional bool clone_newns = 49 [default = true];
inline bool NsJailConfig::_internal_has_clone_newns() const {
  bool value = (_has_bits_[2] & 0x00000004u) != 0;
  return value;
}
inline bool NsJailConfig::has_clone_newns() const {
  return _internal_has_clone_newns();
}
inline void NsJailConfig::clear_clone_newns() {
  clone_newns_ = true;
  _has_bits_[2] &= ~0x00000004u;
}
inline bool NsJailConfig::_internal_clone_newns() const {
  return clone_newns_;
}
inline bool NsJailConfig::clone_newns() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newns)
  return _internal_clone_newns();
}
inline void NsJailConfig::_internal_set_clone_newns(bool value) {
  _has_bits_[2] |= 0x00000004u;
  clone_newns_ = value;
}
inline void NsJailConfig::set_clone_newns(bool value) {
  _internal_set_clone_newns(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newns)
}

// optional bool clone_newpid = 50 [default = true];
inline bool NsJailConfig::_internal_has_clone_newpid() const {
  bool value = (_has_bits_[2] & 0x00000008u) != 0;
  return value;
}
inline bool NsJailConfig::has_clone_newpid() const {
  return _internal_has_clone_newpid();
}
inline void NsJailConfig::clear_clone_newpid() {
  clone_newpid_ = true;
  _has_bits_[2] &= ~0x00000008u;
}
inline bool NsJailConfig::_internal_clone_newpid() const {
  return clone_newpid_;
}
inline bool NsJailConfig::clone_newpid() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newpid)
  return _internal_clone_newpid();
}
inline void NsJailConfig::_internal_set_clone_newpid(bool value) {
  _has_bits_[2] |= 0x00000008u;
  clone_newpid_ = value;
}
inline void NsJailConfig::set_clone_newpid(bool value) {
  _internal_set_clone_newpid(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newpid)
}

// optional bool clone_newipc = 51 [default = true];
inline bool NsJailConfig::_internal_has_clone_newipc() const {
  bool value = (_has_bits_[2] & 0x00000010u) != 0;
  return value;
}
inline bool NsJailConfig::has_clone_newipc() const {
  return _internal_has_clone_newipc();
}
inline void NsJailConfig::clear_clone_newipc() {
  clone_newipc_ = true;
  _has_bits_[2] &= ~0x00000010u;
}
inline bool NsJailConfig::_internal_clone_newipc() const {
  return clone_newipc_;
}
inline bool NsJailConfig::clone_newipc() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newipc)
  return _internal_clone_newipc();
}
inline void NsJailConfig::_internal_set_clone_newipc(bool value) {
  _has_bits_[2] |= 0x00000010u;
  clone_newipc_ = value;
}
inline void NsJailConfig::set_clone_newipc(bool value) {
  _internal_set_clone_newipc(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newipc)
}

// optional bool clone_newuts = 52 [default = true];
inline bool NsJailConfig::_internal_has_clone_newuts() const {
  bool value = (_has_bits_[2] & 0x00000020u) != 0;
  return value;
}
inline bool NsJailConfig::has_clone_newuts() const {
  return _internal_has_clone_newuts();
}
inline void NsJailConfig::clear_clone_newuts() {
  clone_newuts_ = true;
  _has_bits_[2] &= ~0x00000020u;
}
inline bool NsJailConfig::_internal_clone_newuts() const {
  return clone_newuts_;
}
inline bool NsJailConfig::clone_newuts() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newuts)
  return _internal_clone_newuts();
}
inline void NsJailConfig::_internal_set_clone_newuts(bool value) {
  _has_bits_[2] |= 0x00000020u;
  clone_newuts_ = value;
}
inline void NsJailConfig::set_clone_newuts(bool value) {
  _internal_set_clone_newuts(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newuts)
}

// optional bool clone_newcgroup = 53 [default = true];
inline bool NsJailConfig::_internal_has_clone_newcgroup() const {
  bool value = (_has_bits_[2] & 0x00000040u) != 0;
  return value;
}
inline bool NsJailConfig::has_clone_newcgroup() const {
  return _internal_has_clone_newcgroup();
}
inline void NsJailConfig::clear_clone_newcgroup() {
  clone_newcgroup_ = true;
  _has_bits_[2] &= ~0x00000040u;
}
inline bool NsJailConfig::_internal_clone_newcgroup() const {
  return clone_newcgroup_;
}
inline bool NsJailConfig::clone_newcgroup() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.clone_newcgroup)
  return _internal_clone_newcgroup();
}
inline void NsJailConfig::_internal_set_clone_newcgroup(bool value) {
  _has_bits_[2] |= 0x00000040u;
  clone_newcgroup_ = value;
}
inline void NsJailConfig::set_clone_newcgroup(bool value) {
  _internal_set_clone_newcgroup(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.clone_newcgroup)
}

// repeated .nsjail.IdMap uidmap = 54;
inline int NsJailConfig::_internal_uidmap_size() const {
  return uidmap_.size();
}
inline int NsJailConfig::uidmap_size() const {
  return _internal_uidmap_size();
}
inline void NsJailConfig::clear_uidmap() {
  uidmap_.Clear();
}
inline ::nsjail::IdMap* NsJailConfig::mutable_uidmap(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.uidmap)
  return uidmap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >*
NsJailConfig::mutable_uidmap() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.uidmap)
  return &uidmap_;
}
inline const ::nsjail::IdMap& NsJailConfig::_internal_uidmap(int index) const {
  return uidmap_.Get(index);
}
inline const ::nsjail::IdMap& NsJailConfig::uidmap(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.uidmap)
  return _internal_uidmap(index);
}
inline ::nsjail::IdMap* NsJailConfig::_internal_add_uidmap() {
  return uidmap_.Add();
}
inline ::nsjail::IdMap* NsJailConfig::add_uidmap() {
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.uidmap)
  return _internal_add_uidmap();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >&
NsJailConfig::uidmap() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.uidmap)
  return uidmap_;
}

// repeated .nsjail.IdMap gidmap = 55;
inline int NsJailConfig::_internal_gidmap_size() const {
  return gidmap_.size();
}
inline int NsJailConfig::gidmap_size() const {
  return _internal_gidmap_size();
}
inline void NsJailConfig::clear_gidmap() {
  gidmap_.Clear();
}
inline ::nsjail::IdMap* NsJailConfig::mutable_gidmap(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.gidmap)
  return gidmap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >*
NsJailConfig::mutable_gidmap() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.gidmap)
  return &gidmap_;
}
inline const ::nsjail::IdMap& NsJailConfig::_internal_gidmap(int index) const {
  return gidmap_.Get(index);
}
inline const ::nsjail::IdMap& NsJailConfig::gidmap(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.gidmap)
  return _internal_gidmap(index);
}
inline ::nsjail::IdMap* NsJailConfig::_internal_add_gidmap() {
  return gidmap_.Add();
}
inline ::nsjail::IdMap* NsJailConfig::add_gidmap() {
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.gidmap)
  return _internal_add_gidmap();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::IdMap >&
NsJailConfig::gidmap() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.gidmap)
  return gidmap_;
}

// optional bool mount_proc = 56 [default = false];
inline bool NsJailConfig::_internal_has_mount_proc() const {
  bool value = (_has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool NsJailConfig::has_mount_proc() const {
  return _internal_has_mount_proc();
}
inline void NsJailConfig::clear_mount_proc() {
  mount_proc_ = false;
  _has_bits_[1] &= ~0x00002000u;
}
inline bool NsJailConfig::_internal_mount_proc() const {
  return mount_proc_;
}
inline bool NsJailConfig::mount_proc() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.mount_proc)
  return _internal_mount_proc();
}
inline void NsJailConfig::_internal_set_mount_proc(bool value) {
  _has_bits_[1] |= 0x00002000u;
  mount_proc_ = value;
}
inline void NsJailConfig::set_mount_proc(bool value) {
  _internal_set_mount_proc(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.mount_proc)
}

// repeated .nsjail.MountPt mount = 57;
inline int NsJailConfig::_internal_mount_size() const {
  return mount_.size();
}
inline int NsJailConfig::mount_size() const {
  return _internal_mount_size();
}
inline void NsJailConfig::clear_mount() {
  mount_.Clear();
}
inline ::nsjail::MountPt* NsJailConfig::mutable_mount(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.mount)
  return mount_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::MountPt >*
NsJailConfig::mutable_mount() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.mount)
  return &mount_;
}
inline const ::nsjail::MountPt& NsJailConfig::_internal_mount(int index) const {
  return mount_.Get(index);
}
inline const ::nsjail::MountPt& NsJailConfig::mount(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.mount)
  return _internal_mount(index);
}
inline ::nsjail::MountPt* NsJailConfig::_internal_add_mount() {
  return mount_.Add();
}
inline ::nsjail::MountPt* NsJailConfig::add_mount() {
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.mount)
  return _internal_add_mount();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nsjail::MountPt >&
NsJailConfig::mount() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.mount)
  return mount_;
}

// optional string seccomp_policy_file = 58;
inline bool NsJailConfig::_internal_has_seccomp_policy_file() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NsJailConfig::has_seccomp_policy_file() const {
  return _internal_has_seccomp_policy_file();
}
inline void NsJailConfig::clear_seccomp_policy_file() {
  seccomp_policy_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& NsJailConfig::seccomp_policy_file() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.seccomp_policy_file)
  return _internal_seccomp_policy_file();
}
inline void NsJailConfig::set_seccomp_policy_file(const std::string& value) {
  _internal_set_seccomp_policy_file(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_policy_file)
}
inline std::string* NsJailConfig::mutable_seccomp_policy_file() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.seccomp_policy_file)
  return _internal_mutable_seccomp_policy_file();
}
inline const std::string& NsJailConfig::_internal_seccomp_policy_file() const {
  return seccomp_policy_file_.Get();
}
inline void NsJailConfig::_internal_set_seccomp_policy_file(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  seccomp_policy_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_seccomp_policy_file(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  seccomp_policy_file_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.seccomp_policy_file)
}
inline void NsJailConfig::set_seccomp_policy_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  seccomp_policy_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.seccomp_policy_file)
}
inline void NsJailConfig::set_seccomp_policy_file(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  seccomp_policy_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.seccomp_policy_file)
}
inline std::string* NsJailConfig::_internal_mutable_seccomp_policy_file() {
  _has_bits_[0] |= 0x00000020u;
  return seccomp_policy_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NsJailConfig::release_seccomp_policy_file() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.seccomp_policy_file)
  if (!_internal_has_seccomp_policy_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return seccomp_policy_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NsJailConfig::set_allocated_seccomp_policy_file(std::string* seccomp_policy_file) {
  if (seccomp_policy_file != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  seccomp_policy_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), seccomp_policy_file,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.seccomp_policy_file)
}

// repeated string seccomp_string = 59;
inline int NsJailConfig::_internal_seccomp_string_size() const {
  return seccomp_string_.size();
}
inline int NsJailConfig::seccomp_string_size() const {
  return _internal_seccomp_string_size();
}
inline void NsJailConfig::clear_seccomp_string() {
  seccomp_string_.Clear();
}
inline std::string* NsJailConfig::add_seccomp_string() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.seccomp_string)
  return _internal_add_seccomp_string();
}
inline const std::string& NsJailConfig::_internal_seccomp_string(int index) const {
  return seccomp_string_.Get(index);
}
inline const std::string& NsJailConfig::seccomp_string(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.seccomp_string)
  return _internal_seccomp_string(index);
}
inline std::string* NsJailConfig::mutable_seccomp_string(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.seccomp_string)
  return seccomp_string_.Mutable(index);
}
inline void NsJailConfig::set_seccomp_string(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_string)
  seccomp_string_.Mutable(index)->assign(value);
}
inline void NsJailConfig::set_seccomp_string(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_string)
  seccomp_string_.Mutable(index)->assign(std::move(value));
}
inline void NsJailConfig::set_seccomp_string(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  seccomp_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.seccomp_string)
}
inline void NsJailConfig::set_seccomp_string(int index, const char* value, size_t size) {
  seccomp_string_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.seccomp_string)
}
inline std::string* NsJailConfig::_internal_add_seccomp_string() {
  return seccomp_string_.Add();
}
inline void NsJailConfig::add_seccomp_string(const std::string& value) {
  seccomp_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.seccomp_string)
}
inline void NsJailConfig::add_seccomp_string(std::string&& value) {
  seccomp_string_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.seccomp_string)
}
inline void NsJailConfig::add_seccomp_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  seccomp_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.seccomp_string)
}
inline void NsJailConfig::add_seccomp_string(const char* value, size_t size) {
  seccomp_string_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.seccomp_string)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NsJailConfig::seccomp_string() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.seccomp_string)
  return seccomp_string_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NsJailConfig::mutable_seccomp_string() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.seccomp_string)
  return &seccomp_string_;
}

// optional bool seccomp_log = 60 [default = false];
inline bool NsJailConfig::_internal_has_seccomp_log() const {
  bool value = (_has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool NsJailConfig::has_seccomp_log() const {
  return _internal_has_seccomp_log();
}
inline void NsJailConfig::clear_seccomp_log() {
  seccomp_log_ = false;
  _has_bits_[1] &= ~0x00004000u;
}
inline bool NsJailConfig::_internal_seccomp_log() const {
  return seccomp_log_;
}
inline bool NsJailConfig::seccomp_log() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.seccomp_log)
  return _internal_seccomp_log();
}
inline void NsJailConfig::_internal_set_seccomp_log(bool value) {
  _has_bits_[1] |= 0x00004000u;
  seccomp_log_ = value;
}
inline void NsJailConfig::set_seccomp_log(bool value) {
  _internal_set_seccomp_log(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.seccomp_log)
}

// optional uint64 cgroup_mem_max = 61 [default = 0];
inline bool NsJailConfig::_internal_has_cgroup_mem_max() const {
  bool value = (_has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_mem_max() const {
  return _internal_has_cgroup_mem_max();
}
inline void NsJailConfig::clear_cgroup_mem_max() {
  cgroup_mem_max_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[1] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_cgroup_mem_max() const {
  return cgroup_mem_max_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::cgroup_mem_max() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_max)
  return _internal_cgroup_mem_max();
}
inline void NsJailConfig::_internal_set_cgroup_mem_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x00010000u;
  cgroup_mem_max_ = value;
}
inline void NsJailConfig::set_cgroup_mem_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_cgroup_mem_max(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_max)
}

// optional string cgroup_mem_mount = 62 [default = "/sys/fs/cgroup/memory"];
inline bool NsJailConfig::_internal_has_cgroup_mem_mount() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_mem_mount() const {
  return _internal_has_cgroup_mem_mount();
}
inline void NsJailConfig::clear_cgroup_mem_mount() {
  cgroup_mem_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_, GetArena());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& NsJailConfig::cgroup_mem_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_mount)
  if (cgroup_mem_mount_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_mem_mount_.get();
  return _internal_cgroup_mem_mount();
}
inline void NsJailConfig::set_cgroup_mem_mount(const std::string& value) {
  _internal_set_cgroup_mem_mount(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_mount)
}
inline std::string* NsJailConfig::mutable_cgroup_mem_mount() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_mem_mount)
  return _internal_mutable_cgroup_mem_mount();
}
inline const std::string& NsJailConfig::_internal_cgroup_mem_mount() const {
  return cgroup_mem_mount_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_mem_mount(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  cgroup_mem_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_mem_mount(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  cgroup_mem_mount_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_mem_mount)
}
inline void NsJailConfig::set_cgroup_mem_mount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  cgroup_mem_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_mem_mount)
}
inline void NsJailConfig::set_cgroup_mem_mount(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  cgroup_mem_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_mem_mount)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_mem_mount() {
  _has_bits_[0] |= 0x00000040u;
  return cgroup_mem_mount_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_mount_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_mem_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_mem_mount)
  if (!_internal_has_cgroup_mem_mount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return cgroup_mem_mount_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_mem_mount(std::string* cgroup_mem_mount) {
  if (cgroup_mem_mount != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  cgroup_mem_mount_.SetAllocated(nullptr, cgroup_mem_mount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_mem_mount)
}

// optional string cgroup_mem_parent = 63 [default = "NSJAIL"];
inline bool NsJailConfig::_internal_has_cgroup_mem_parent() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_mem_parent() const {
  return _internal_has_cgroup_mem_parent();
}
inline void NsJailConfig::clear_cgroup_mem_parent() {
  cgroup_mem_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_, GetArena());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& NsJailConfig::cgroup_mem_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_mem_parent)
  if (cgroup_mem_parent_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_mem_parent_.get();
  return _internal_cgroup_mem_parent();
}
inline void NsJailConfig::set_cgroup_mem_parent(const std::string& value) {
  _internal_set_cgroup_mem_parent(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_mem_parent)
}
inline std::string* NsJailConfig::mutable_cgroup_mem_parent() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_mem_parent)
  return _internal_mutable_cgroup_mem_parent();
}
inline const std::string& NsJailConfig::_internal_cgroup_mem_parent() const {
  return cgroup_mem_parent_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_mem_parent(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  cgroup_mem_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_mem_parent(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  cgroup_mem_parent_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_mem_parent)
}
inline void NsJailConfig::set_cgroup_mem_parent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  cgroup_mem_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_mem_parent)
}
inline void NsJailConfig::set_cgroup_mem_parent(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  cgroup_mem_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_mem_parent)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_mem_parent() {
  _has_bits_[0] |= 0x00000080u;
  return cgroup_mem_parent_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_mem_parent_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_mem_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_mem_parent)
  if (!_internal_has_cgroup_mem_parent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return cgroup_mem_parent_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_mem_parent(std::string* cgroup_mem_parent) {
  if (cgroup_mem_parent != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  cgroup_mem_parent_.SetAllocated(nullptr, cgroup_mem_parent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_mem_parent)
}

// optional uint64 cgroup_pids_max = 64 [default = 0];
inline bool NsJailConfig::_internal_has_cgroup_pids_max() const {
  bool value = (_has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_pids_max() const {
  return _internal_has_cgroup_pids_max();
}
inline void NsJailConfig::clear_cgroup_pids_max() {
  cgroup_pids_max_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[1] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::_internal_cgroup_pids_max() const {
  return cgroup_pids_max_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NsJailConfig::cgroup_pids_max() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_pids_max)
  return _internal_cgroup_pids_max();
}
inline void NsJailConfig::_internal_set_cgroup_pids_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[1] |= 0x00020000u;
  cgroup_pids_max_ = value;
}
inline void NsJailConfig::set_cgroup_pids_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_cgroup_pids_max(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_pids_max)
}

// optional string cgroup_pids_mount = 65 [default = "/sys/fs/cgroup/pids"];
inline bool NsJailConfig::_internal_has_cgroup_pids_mount() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_pids_mount() const {
  return _internal_has_cgroup_pids_mount();
}
inline void NsJailConfig::clear_cgroup_pids_mount() {
  cgroup_pids_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_, GetArena());
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& NsJailConfig::cgroup_pids_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_pids_mount)
  if (cgroup_pids_mount_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_pids_mount_.get();
  return _internal_cgroup_pids_mount();
}
inline void NsJailConfig::set_cgroup_pids_mount(const std::string& value) {
  _internal_set_cgroup_pids_mount(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_pids_mount)
}
inline std::string* NsJailConfig::mutable_cgroup_pids_mount() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_pids_mount)
  return _internal_mutable_cgroup_pids_mount();
}
inline const std::string& NsJailConfig::_internal_cgroup_pids_mount() const {
  return cgroup_pids_mount_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_pids_mount(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  cgroup_pids_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_pids_mount(std::string&& value) {
  _has_bits_[0] |= 0x00000100u;
  cgroup_pids_mount_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_pids_mount)
}
inline void NsJailConfig::set_cgroup_pids_mount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000100u;
  cgroup_pids_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_pids_mount)
}
inline void NsJailConfig::set_cgroup_pids_mount(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000100u;
  cgroup_pids_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_pids_mount)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_pids_mount() {
  _has_bits_[0] |= 0x00000100u;
  return cgroup_pids_mount_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_mount_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_pids_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_pids_mount)
  if (!_internal_has_cgroup_pids_mount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return cgroup_pids_mount_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_pids_mount(std::string* cgroup_pids_mount) {
  if (cgroup_pids_mount != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  cgroup_pids_mount_.SetAllocated(nullptr, cgroup_pids_mount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_pids_mount)
}

// optional string cgroup_pids_parent = 66 [default = "NSJAIL"];
inline bool NsJailConfig::_internal_has_cgroup_pids_parent() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_pids_parent() const {
  return _internal_has_cgroup_pids_parent();
}
inline void NsJailConfig::clear_cgroup_pids_parent() {
  cgroup_pids_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_, GetArena());
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& NsJailConfig::cgroup_pids_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_pids_parent)
  if (cgroup_pids_parent_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_pids_parent_.get();
  return _internal_cgroup_pids_parent();
}
inline void NsJailConfig::set_cgroup_pids_parent(const std::string& value) {
  _internal_set_cgroup_pids_parent(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_pids_parent)
}
inline std::string* NsJailConfig::mutable_cgroup_pids_parent() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_pids_parent)
  return _internal_mutable_cgroup_pids_parent();
}
inline const std::string& NsJailConfig::_internal_cgroup_pids_parent() const {
  return cgroup_pids_parent_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_pids_parent(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  cgroup_pids_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_pids_parent(std::string&& value) {
  _has_bits_[0] |= 0x00000200u;
  cgroup_pids_parent_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_pids_parent)
}
inline void NsJailConfig::set_cgroup_pids_parent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000200u;
  cgroup_pids_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_pids_parent)
}
inline void NsJailConfig::set_cgroup_pids_parent(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000200u;
  cgroup_pids_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_pids_parent)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_pids_parent() {
  _has_bits_[0] |= 0x00000200u;
  return cgroup_pids_parent_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_pids_parent_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_pids_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_pids_parent)
  if (!_internal_has_cgroup_pids_parent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return cgroup_pids_parent_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_pids_parent(std::string* cgroup_pids_parent) {
  if (cgroup_pids_parent != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  cgroup_pids_parent_.SetAllocated(nullptr, cgroup_pids_parent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_pids_parent)
}

// optional uint32 cgroup_net_cls_classid = 67 [default = 0];
inline bool NsJailConfig::_internal_has_cgroup_net_cls_classid() const {
  bool value = (_has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_net_cls_classid() const {
  return _internal_has_cgroup_net_cls_classid();
}
inline void NsJailConfig::clear_cgroup_net_cls_classid() {
  cgroup_net_cls_classid_ = 0u;
  _has_bits_[1] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::_internal_cgroup_net_cls_classid() const {
  return cgroup_net_cls_classid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::cgroup_net_cls_classid() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_net_cls_classid)
  return _internal_cgroup_net_cls_classid();
}
inline void NsJailConfig::_internal_set_cgroup_net_cls_classid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00040000u;
  cgroup_net_cls_classid_ = value;
}
inline void NsJailConfig::set_cgroup_net_cls_classid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cgroup_net_cls_classid(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_net_cls_classid)
}

// optional string cgroup_net_cls_mount = 68 [default = "/sys/fs/cgroup/net_cls"];
inline bool NsJailConfig::_internal_has_cgroup_net_cls_mount() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_net_cls_mount() const {
  return _internal_has_cgroup_net_cls_mount();
}
inline void NsJailConfig::clear_cgroup_net_cls_mount() {
  cgroup_net_cls_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_, GetArena());
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& NsJailConfig::cgroup_net_cls_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_net_cls_mount)
  if (cgroup_net_cls_mount_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_.get();
  return _internal_cgroup_net_cls_mount();
}
inline void NsJailConfig::set_cgroup_net_cls_mount(const std::string& value) {
  _internal_set_cgroup_net_cls_mount(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
inline std::string* NsJailConfig::mutable_cgroup_net_cls_mount() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_net_cls_mount)
  return _internal_mutable_cgroup_net_cls_mount();
}
inline const std::string& NsJailConfig::_internal_cgroup_net_cls_mount() const {
  return cgroup_net_cls_mount_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_net_cls_mount(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  cgroup_net_cls_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_net_cls_mount(std::string&& value) {
  _has_bits_[0] |= 0x00000400u;
  cgroup_net_cls_mount_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
inline void NsJailConfig::set_cgroup_net_cls_mount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000400u;
  cgroup_net_cls_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
inline void NsJailConfig::set_cgroup_net_cls_mount(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000400u;
  cgroup_net_cls_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_net_cls_mount)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_net_cls_mount() {
  _has_bits_[0] |= 0x00000400u;
  return cgroup_net_cls_mount_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_mount_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_net_cls_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_net_cls_mount)
  if (!_internal_has_cgroup_net_cls_mount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  return cgroup_net_cls_mount_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_net_cls_mount(std::string* cgroup_net_cls_mount) {
  if (cgroup_net_cls_mount != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  cgroup_net_cls_mount_.SetAllocated(nullptr, cgroup_net_cls_mount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_net_cls_mount)
}

// optional string cgroup_net_cls_parent = 69 [default = "NSJAIL"];
inline bool NsJailConfig::_internal_has_cgroup_net_cls_parent() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_net_cls_parent() const {
  return _internal_has_cgroup_net_cls_parent();
}
inline void NsJailConfig::clear_cgroup_net_cls_parent() {
  cgroup_net_cls_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_, GetArena());
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& NsJailConfig::cgroup_net_cls_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_net_cls_parent)
  if (cgroup_net_cls_parent_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_.get();
  return _internal_cgroup_net_cls_parent();
}
inline void NsJailConfig::set_cgroup_net_cls_parent(const std::string& value) {
  _internal_set_cgroup_net_cls_parent(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
inline std::string* NsJailConfig::mutable_cgroup_net_cls_parent() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_net_cls_parent)
  return _internal_mutable_cgroup_net_cls_parent();
}
inline const std::string& NsJailConfig::_internal_cgroup_net_cls_parent() const {
  return cgroup_net_cls_parent_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_net_cls_parent(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  cgroup_net_cls_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_net_cls_parent(std::string&& value) {
  _has_bits_[0] |= 0x00000800u;
  cgroup_net_cls_parent_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
inline void NsJailConfig::set_cgroup_net_cls_parent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000800u;
  cgroup_net_cls_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
inline void NsJailConfig::set_cgroup_net_cls_parent(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000800u;
  cgroup_net_cls_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_net_cls_parent)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_net_cls_parent() {
  _has_bits_[0] |= 0x00000800u;
  return cgroup_net_cls_parent_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_net_cls_parent_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_net_cls_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_net_cls_parent)
  if (!_internal_has_cgroup_net_cls_parent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  return cgroup_net_cls_parent_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_net_cls_parent(std::string* cgroup_net_cls_parent) {
  if (cgroup_net_cls_parent != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  cgroup_net_cls_parent_.SetAllocated(nullptr, cgroup_net_cls_parent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_net_cls_parent)
}

// optional uint32 cgroup_cpu_ms_per_sec = 70 [default = 0];
inline bool NsJailConfig::_internal_has_cgroup_cpu_ms_per_sec() const {
  bool value = (_has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_cpu_ms_per_sec() const {
  return _internal_has_cgroup_cpu_ms_per_sec();
}
inline void NsJailConfig::clear_cgroup_cpu_ms_per_sec() {
  cgroup_cpu_ms_per_sec_ = 0u;
  _has_bits_[1] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::_internal_cgroup_cpu_ms_per_sec() const {
  return cgroup_cpu_ms_per_sec_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NsJailConfig::cgroup_cpu_ms_per_sec() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_cpu_ms_per_sec)
  return _internal_cgroup_cpu_ms_per_sec();
}
inline void NsJailConfig::_internal_set_cgroup_cpu_ms_per_sec(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00080000u;
  cgroup_cpu_ms_per_sec_ = value;
}
inline void NsJailConfig::set_cgroup_cpu_ms_per_sec(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cgroup_cpu_ms_per_sec(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_cpu_ms_per_sec)
}

// optional string cgroup_cpu_mount = 71 [default = "/sys/fs/cgroup/cpu"];
inline bool NsJailConfig::_internal_has_cgroup_cpu_mount() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_cpu_mount() const {
  return _internal_has_cgroup_cpu_mount();
}
inline void NsJailConfig::clear_cgroup_cpu_mount() {
  cgroup_cpu_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_, GetArena());
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& NsJailConfig::cgroup_cpu_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_cpu_mount)
  if (cgroup_cpu_mount_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_cpu_mount_.get();
  return _internal_cgroup_cpu_mount();
}
inline void NsJailConfig::set_cgroup_cpu_mount(const std::string& value) {
  _internal_set_cgroup_cpu_mount(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_cpu_mount)
}
inline std::string* NsJailConfig::mutable_cgroup_cpu_mount() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_cpu_mount)
  return _internal_mutable_cgroup_cpu_mount();
}
inline const std::string& NsJailConfig::_internal_cgroup_cpu_mount() const {
  return cgroup_cpu_mount_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_cpu_mount(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  cgroup_cpu_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_cpu_mount(std::string&& value) {
  _has_bits_[0] |= 0x00001000u;
  cgroup_cpu_mount_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_cpu_mount)
}
inline void NsJailConfig::set_cgroup_cpu_mount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00001000u;
  cgroup_cpu_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_cpu_mount)
}
inline void NsJailConfig::set_cgroup_cpu_mount(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00001000u;
  cgroup_cpu_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_cpu_mount)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_cpu_mount() {
  _has_bits_[0] |= 0x00001000u;
  return cgroup_cpu_mount_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_mount_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_cpu_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_cpu_mount)
  if (!_internal_has_cgroup_cpu_mount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  return cgroup_cpu_mount_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_cpu_mount(std::string* cgroup_cpu_mount) {
  if (cgroup_cpu_mount != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  cgroup_cpu_mount_.SetAllocated(nullptr, cgroup_cpu_mount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_cpu_mount)
}

// optional string cgroup_cpu_parent = 72 [default = "NSJAIL"];
inline bool NsJailConfig::_internal_has_cgroup_cpu_parent() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroup_cpu_parent() const {
  return _internal_has_cgroup_cpu_parent();
}
inline void NsJailConfig::clear_cgroup_cpu_parent() {
  cgroup_cpu_parent_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_, GetArena());
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& NsJailConfig::cgroup_cpu_parent() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroup_cpu_parent)
  if (cgroup_cpu_parent_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroup_cpu_parent_.get();
  return _internal_cgroup_cpu_parent();
}
inline void NsJailConfig::set_cgroup_cpu_parent(const std::string& value) {
  _internal_set_cgroup_cpu_parent(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroup_cpu_parent)
}
inline std::string* NsJailConfig::mutable_cgroup_cpu_parent() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroup_cpu_parent)
  return _internal_mutable_cgroup_cpu_parent();
}
inline const std::string& NsJailConfig::_internal_cgroup_cpu_parent() const {
  return cgroup_cpu_parent_.Get();
}
inline void NsJailConfig::_internal_set_cgroup_cpu_parent(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  cgroup_cpu_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroup_cpu_parent(std::string&& value) {
  _has_bits_[0] |= 0x00002000u;
  cgroup_cpu_parent_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroup_cpu_parent)
}
inline void NsJailConfig::set_cgroup_cpu_parent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00002000u;
  cgroup_cpu_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroup_cpu_parent)
}
inline void NsJailConfig::set_cgroup_cpu_parent(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00002000u;
  cgroup_cpu_parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroup_cpu_parent)
}
inline std::string* NsJailConfig::_internal_mutable_cgroup_cpu_parent() {
  _has_bits_[0] |= 0x00002000u;
  return cgroup_cpu_parent_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroup_cpu_parent_, GetArena());
}
inline std::string* NsJailConfig::release_cgroup_cpu_parent() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroup_cpu_parent)
  if (!_internal_has_cgroup_cpu_parent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  return cgroup_cpu_parent_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroup_cpu_parent(std::string* cgroup_cpu_parent) {
  if (cgroup_cpu_parent != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  cgroup_cpu_parent_.SetAllocated(nullptr, cgroup_cpu_parent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroup_cpu_parent)
}

// optional string cgroupv2_mount = 73 [default = "/sys/fs/cgroup"];
inline bool NsJailConfig::_internal_has_cgroupv2_mount() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool NsJailConfig::has_cgroupv2_mount() const {
  return _internal_has_cgroupv2_mount();
}
inline void NsJailConfig::clear_cgroupv2_mount() {
  cgroupv2_mount_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_, GetArena());
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& NsJailConfig::cgroupv2_mount() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.cgroupv2_mount)
  if (cgroupv2_mount_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cgroupv2_mount_.get();
  return _internal_cgroupv2_mount();
}
inline void NsJailConfig::set_cgroupv2_mount(const std::string& value) {
  _internal_set_cgroupv2_mount(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.cgroupv2_mount)
}
inline std::string* NsJailConfig::mutable_cgroupv2_mount() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.cgroupv2_mount)
  return _internal_mutable_cgroupv2_mount();
}
inline const std::string& NsJailConfig::_internal_cgroupv2_mount() const {
  return cgroupv2_mount_.Get();
}
inline void NsJailConfig::_internal_set_cgroupv2_mount(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  cgroupv2_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_cgroupv2_mount(std::string&& value) {
  _has_bits_[0] |= 0x00004000u;
  cgroupv2_mount_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.cgroupv2_mount)
}
inline void NsJailConfig::set_cgroupv2_mount(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00004000u;
  cgroupv2_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.cgroupv2_mount)
}
inline void NsJailConfig::set_cgroupv2_mount(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00004000u;
  cgroupv2_mount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.cgroupv2_mount)
}
inline std::string* NsJailConfig::_internal_mutable_cgroupv2_mount() {
  _has_bits_[0] |= 0x00004000u;
  return cgroupv2_mount_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_cgroupv2_mount_, GetArena());
}
inline std::string* NsJailConfig::release_cgroupv2_mount() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.cgroupv2_mount)
  if (!_internal_has_cgroupv2_mount()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  return cgroupv2_mount_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_cgroupv2_mount(std::string* cgroupv2_mount) {
  if (cgroupv2_mount != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  cgroupv2_mount_.SetAllocated(nullptr, cgroupv2_mount,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.cgroupv2_mount)
}

// optional bool use_cgroupv2 = 74 [default = false];
inline bool NsJailConfig::_internal_has_use_cgroupv2() const {
  bool value = (_has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool NsJailConfig::has_use_cgroupv2() const {
  return _internal_has_use_cgroupv2();
}
inline void NsJailConfig::clear_use_cgroupv2() {
  use_cgroupv2_ = false;
  _has_bits_[1] &= ~0x00008000u;
}
inline bool NsJailConfig::_internal_use_cgroupv2() const {
  return use_cgroupv2_;
}
inline bool NsJailConfig::use_cgroupv2() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.use_cgroupv2)
  return _internal_use_cgroupv2();
}
inline void NsJailConfig::_internal_set_use_cgroupv2(bool value) {
  _has_bits_[1] |= 0x00008000u;
  use_cgroupv2_ = value;
}
inline void NsJailConfig::set_use_cgroupv2(bool value) {
  _internal_set_use_cgroupv2(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.use_cgroupv2)
}

// optional bool iface_no_lo = 75 [default = false];
inline bool NsJailConfig::_internal_has_iface_no_lo() const {
  bool value = (_has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline bool NsJailConfig::has_iface_no_lo() const {
  return _internal_has_iface_no_lo();
}
inline void NsJailConfig::clear_iface_no_lo() {
  iface_no_lo_ = false;
  _has_bits_[1] &= ~0x00100000u;
}
inline bool NsJailConfig::_internal_iface_no_lo() const {
  return iface_no_lo_;
}
inline bool NsJailConfig::iface_no_lo() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.iface_no_lo)
  return _internal_iface_no_lo();
}
inline void NsJailConfig::_internal_set_iface_no_lo(bool value) {
  _has_bits_[1] |= 0x00100000u;
  iface_no_lo_ = value;
}
inline void NsJailConfig::set_iface_no_lo(bool value) {
  _internal_set_iface_no_lo(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.iface_no_lo)
}

// repeated string iface_own = 76;
inline int NsJailConfig::_internal_iface_own_size() const {
  return iface_own_.size();
}
inline int NsJailConfig::iface_own_size() const {
  return _internal_iface_own_size();
}
inline void NsJailConfig::clear_iface_own() {
  iface_own_.Clear();
}
inline std::string* NsJailConfig::add_iface_own() {
  // @@protoc_insertion_point(field_add_mutable:nsjail.NsJailConfig.iface_own)
  return _internal_add_iface_own();
}
inline const std::string& NsJailConfig::_internal_iface_own(int index) const {
  return iface_own_.Get(index);
}
inline const std::string& NsJailConfig::iface_own(int index) const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.iface_own)
  return _internal_iface_own(index);
}
inline std::string* NsJailConfig::mutable_iface_own(int index) {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.iface_own)
  return iface_own_.Mutable(index);
}
inline void NsJailConfig::set_iface_own(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.iface_own)
  iface_own_.Mutable(index)->assign(value);
}
inline void NsJailConfig::set_iface_own(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.iface_own)
  iface_own_.Mutable(index)->assign(std::move(value));
}
inline void NsJailConfig::set_iface_own(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  iface_own_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.iface_own)
}
inline void NsJailConfig::set_iface_own(int index, const char* value, size_t size) {
  iface_own_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.iface_own)
}
inline std::string* NsJailConfig::_internal_add_iface_own() {
  return iface_own_.Add();
}
inline void NsJailConfig::add_iface_own(const std::string& value) {
  iface_own_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.iface_own)
}
inline void NsJailConfig::add_iface_own(std::string&& value) {
  iface_own_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:nsjail.NsJailConfig.iface_own)
}
inline void NsJailConfig::add_iface_own(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  iface_own_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsjail.NsJailConfig.iface_own)
}
inline void NsJailConfig::add_iface_own(const char* value, size_t size) {
  iface_own_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsjail.NsJailConfig.iface_own)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NsJailConfig::iface_own() const {
  // @@protoc_insertion_point(field_list:nsjail.NsJailConfig.iface_own)
  return iface_own_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NsJailConfig::mutable_iface_own() {
  // @@protoc_insertion_point(field_mutable_list:nsjail.NsJailConfig.iface_own)
  return &iface_own_;
}

// optional string macvlan_iface = 77;
inline bool NsJailConfig::_internal_has_macvlan_iface() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool NsJailConfig::has_macvlan_iface() const {
  return _internal_has_macvlan_iface();
}
inline void NsJailConfig::clear_macvlan_iface() {
  macvlan_iface_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& NsJailConfig::macvlan_iface() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_iface)
  return _internal_macvlan_iface();
}
inline void NsJailConfig::set_macvlan_iface(const std::string& value) {
  _internal_set_macvlan_iface(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_iface)
}
inline std::string* NsJailConfig::mutable_macvlan_iface() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_iface)
  return _internal_mutable_macvlan_iface();
}
inline const std::string& NsJailConfig::_internal_macvlan_iface() const {
  return macvlan_iface_.Get();
}
inline void NsJailConfig::_internal_set_macvlan_iface(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  macvlan_iface_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_macvlan_iface(std::string&& value) {
  _has_bits_[0] |= 0x00008000u;
  macvlan_iface_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_iface)
}
inline void NsJailConfig::set_macvlan_iface(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00008000u;
  macvlan_iface_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_iface)
}
inline void NsJailConfig::set_macvlan_iface(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00008000u;
  macvlan_iface_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_iface)
}
inline std::string* NsJailConfig::_internal_mutable_macvlan_iface() {
  _has_bits_[0] |= 0x00008000u;
  return macvlan_iface_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NsJailConfig::release_macvlan_iface() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_iface)
  if (!_internal_has_macvlan_iface()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  return macvlan_iface_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NsJailConfig::set_allocated_macvlan_iface(std::string* macvlan_iface) {
  if (macvlan_iface != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  macvlan_iface_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), macvlan_iface,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_iface)
}

// optional string macvlan_vs_ip = 78 [default = "192.168.0.2"];
inline bool NsJailConfig::_internal_has_macvlan_vs_ip() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool NsJailConfig::has_macvlan_vs_ip() const {
  return _internal_has_macvlan_vs_ip();
}
inline void NsJailConfig::clear_macvlan_vs_ip() {
  macvlan_vs_ip_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_, GetArena());
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& NsJailConfig::macvlan_vs_ip() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_ip)
  if (macvlan_vs_ip_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_macvlan_vs_ip_.get();
  return _internal_macvlan_vs_ip();
}
inline void NsJailConfig::set_macvlan_vs_ip(const std::string& value) {
  _internal_set_macvlan_vs_ip(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_ip)
}
inline std::string* NsJailConfig::mutable_macvlan_vs_ip() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_ip)
  return _internal_mutable_macvlan_vs_ip();
}
inline const std::string& NsJailConfig::_internal_macvlan_vs_ip() const {
  return macvlan_vs_ip_.Get();
}
inline void NsJailConfig::_internal_set_macvlan_vs_ip(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  macvlan_vs_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_macvlan_vs_ip(std::string&& value) {
  _has_bits_[0] |= 0x00010000u;
  macvlan_vs_ip_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_ip)
}
inline void NsJailConfig::set_macvlan_vs_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00010000u;
  macvlan_vs_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_ip)
}
inline void NsJailConfig::set_macvlan_vs_ip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00010000u;
  macvlan_vs_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_ip)
}
inline std::string* NsJailConfig::_internal_mutable_macvlan_vs_ip() {
  _has_bits_[0] |= 0x00010000u;
  return macvlan_vs_ip_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_ip_, GetArena());
}
inline std::string* NsJailConfig::release_macvlan_vs_ip() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_ip)
  if (!_internal_has_macvlan_vs_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  return macvlan_vs_ip_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_macvlan_vs_ip(std::string* macvlan_vs_ip) {
  if (macvlan_vs_ip != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  macvlan_vs_ip_.SetAllocated(nullptr, macvlan_vs_ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_ip)
}

// optional string macvlan_vs_nm = 79 [default = "255.255.255.0"];
inline bool NsJailConfig::_internal_has_macvlan_vs_nm() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool NsJailConfig::has_macvlan_vs_nm() const {
  return _internal_has_macvlan_vs_nm();
}
inline void NsJailConfig::clear_macvlan_vs_nm() {
  macvlan_vs_nm_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_, GetArena());
  _has_bits_[0] &= ~0x00020000u;
}
inline const std::string& NsJailConfig::macvlan_vs_nm() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_nm)
  if (macvlan_vs_nm_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_macvlan_vs_nm_.get();
  return _internal_macvlan_vs_nm();
}
inline void NsJailConfig::set_macvlan_vs_nm(const std::string& value) {
  _internal_set_macvlan_vs_nm(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_nm)
}
inline std::string* NsJailConfig::mutable_macvlan_vs_nm() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_nm)
  return _internal_mutable_macvlan_vs_nm();
}
inline const std::string& NsJailConfig::_internal_macvlan_vs_nm() const {
  return macvlan_vs_nm_.Get();
}
inline void NsJailConfig::_internal_set_macvlan_vs_nm(const std::string& value) {
  _has_bits_[0] |= 0x00020000u;
  macvlan_vs_nm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_macvlan_vs_nm(std::string&& value) {
  _has_bits_[0] |= 0x00020000u;
  macvlan_vs_nm_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_nm)
}
inline void NsJailConfig::set_macvlan_vs_nm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00020000u;
  macvlan_vs_nm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_nm)
}
inline void NsJailConfig::set_macvlan_vs_nm(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00020000u;
  macvlan_vs_nm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_nm)
}
inline std::string* NsJailConfig::_internal_mutable_macvlan_vs_nm() {
  _has_bits_[0] |= 0x00020000u;
  return macvlan_vs_nm_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_nm_, GetArena());
}
inline std::string* NsJailConfig::release_macvlan_vs_nm() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_nm)
  if (!_internal_has_macvlan_vs_nm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00020000u;
  return macvlan_vs_nm_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_macvlan_vs_nm(std::string* macvlan_vs_nm) {
  if (macvlan_vs_nm != nullptr) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  macvlan_vs_nm_.SetAllocated(nullptr, macvlan_vs_nm,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_nm)
}

// optional string macvlan_vs_gw = 80 [default = "192.168.0.1"];
inline bool NsJailConfig::_internal_has_macvlan_vs_gw() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool NsJailConfig::has_macvlan_vs_gw() const {
  return _internal_has_macvlan_vs_gw();
}
inline void NsJailConfig::clear_macvlan_vs_gw() {
  macvlan_vs_gw_.ClearToDefault(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_, GetArena());
  _has_bits_[0] &= ~0x00040000u;
}
inline const std::string& NsJailConfig::macvlan_vs_gw() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_gw)
  if (macvlan_vs_gw_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_macvlan_vs_gw_.get();
  return _internal_macvlan_vs_gw();
}
inline void NsJailConfig::set_macvlan_vs_gw(const std::string& value) {
  _internal_set_macvlan_vs_gw(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_gw)
}
inline std::string* NsJailConfig::mutable_macvlan_vs_gw() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_gw)
  return _internal_mutable_macvlan_vs_gw();
}
inline const std::string& NsJailConfig::_internal_macvlan_vs_gw() const {
  return macvlan_vs_gw_.Get();
}
inline void NsJailConfig::_internal_set_macvlan_vs_gw(const std::string& value) {
  _has_bits_[0] |= 0x00040000u;
  macvlan_vs_gw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_macvlan_vs_gw(std::string&& value) {
  _has_bits_[0] |= 0x00040000u;
  macvlan_vs_gw_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_gw)
}
inline void NsJailConfig::set_macvlan_vs_gw(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00040000u;
  macvlan_vs_gw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_gw)
}
inline void NsJailConfig::set_macvlan_vs_gw(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00040000u;
  macvlan_vs_gw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_gw)
}
inline std::string* NsJailConfig::_internal_mutable_macvlan_vs_gw() {
  _has_bits_[0] |= 0x00040000u;
  return macvlan_vs_gw_.Mutable(::nsjail::NsJailConfig::_i_give_permission_to_break_this_code_default_macvlan_vs_gw_, GetArena());
}
inline std::string* NsJailConfig::release_macvlan_vs_gw() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_gw)
  if (!_internal_has_macvlan_vs_gw()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00040000u;
  return macvlan_vs_gw_.ReleaseNonDefault(nullptr, GetArena());
}
inline void NsJailConfig::set_allocated_macvlan_vs_gw(std::string* macvlan_vs_gw) {
  if (macvlan_vs_gw != nullptr) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  macvlan_vs_gw_.SetAllocated(nullptr, macvlan_vs_gw,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_gw)
}

// optional string macvlan_vs_ma = 81 [default = ""];
inline bool NsJailConfig::_internal_has_macvlan_vs_ma() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool NsJailConfig::has_macvlan_vs_ma() const {
  return _internal_has_macvlan_vs_ma();
}
inline void NsJailConfig::clear_macvlan_vs_ma() {
  macvlan_vs_ma_.ClearToEmpty();
  _has_bits_[0] &= ~0x00080000u;
}
inline const std::string& NsJailConfig::macvlan_vs_ma() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.macvlan_vs_ma)
  return _internal_macvlan_vs_ma();
}
inline void NsJailConfig::set_macvlan_vs_ma(const std::string& value) {
  _internal_set_macvlan_vs_ma(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.macvlan_vs_ma)
}
inline std::string* NsJailConfig::mutable_macvlan_vs_ma() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.macvlan_vs_ma)
  return _internal_mutable_macvlan_vs_ma();
}
inline const std::string& NsJailConfig::_internal_macvlan_vs_ma() const {
  return macvlan_vs_ma_.Get();
}
inline void NsJailConfig::_internal_set_macvlan_vs_ma(const std::string& value) {
  _has_bits_[0] |= 0x00080000u;
  macvlan_vs_ma_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NsJailConfig::set_macvlan_vs_ma(std::string&& value) {
  _has_bits_[0] |= 0x00080000u;
  macvlan_vs_ma_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:nsjail.NsJailConfig.macvlan_vs_ma)
}
inline void NsJailConfig::set_macvlan_vs_ma(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00080000u;
  macvlan_vs_ma_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:nsjail.NsJailConfig.macvlan_vs_ma)
}
inline void NsJailConfig::set_macvlan_vs_ma(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00080000u;
  macvlan_vs_ma_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:nsjail.NsJailConfig.macvlan_vs_ma)
}
inline std::string* NsJailConfig::_internal_mutable_macvlan_vs_ma() {
  _has_bits_[0] |= 0x00080000u;
  return macvlan_vs_ma_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NsJailConfig::release_macvlan_vs_ma() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.macvlan_vs_ma)
  if (!_internal_has_macvlan_vs_ma()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00080000u;
  return macvlan_vs_ma_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NsJailConfig::set_allocated_macvlan_vs_ma(std::string* macvlan_vs_ma) {
  if (macvlan_vs_ma != nullptr) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  macvlan_vs_ma_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), macvlan_vs_ma,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.macvlan_vs_ma)
}

// optional int32 nice_level = 82 [default = 19];
inline bool NsJailConfig::_internal_has_nice_level() const {
  bool value = (_has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline bool NsJailConfig::has_nice_level() const {
  return _internal_has_nice_level();
}
inline void NsJailConfig::clear_nice_level() {
  nice_level_ = 19;
  _has_bits_[1] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NsJailConfig::_internal_nice_level() const {
  return nice_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NsJailConfig::nice_level() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.nice_level)
  return _internal_nice_level();
}
inline void NsJailConfig::_internal_set_nice_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00200000u;
  nice_level_ = value;
}
inline void NsJailConfig::set_nice_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nice_level(value);
  // @@protoc_insertion_point(field_set:nsjail.NsJailConfig.nice_level)
}

// optional .nsjail.Exe exec_bin = 83;
inline bool NsJailConfig::_internal_has_exec_bin() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || exec_bin_ != nullptr);
  return value;
}
inline bool NsJailConfig::has_exec_bin() const {
  return _internal_has_exec_bin();
}
inline void NsJailConfig::clear_exec_bin() {
  if (exec_bin_ != nullptr) exec_bin_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::nsjail::Exe& NsJailConfig::_internal_exec_bin() const {
  const ::nsjail::Exe* p = exec_bin_;
  return p != nullptr ? *p : reinterpret_cast<const ::nsjail::Exe&>(
      ::nsjail::_Exe_default_instance_);
}
inline const ::nsjail::Exe& NsJailConfig::exec_bin() const {
  // @@protoc_insertion_point(field_get:nsjail.NsJailConfig.exec_bin)
  return _internal_exec_bin();
}
inline void NsJailConfig::unsafe_arena_set_allocated_exec_bin(
    ::nsjail::Exe* exec_bin) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exec_bin_);
  }
  exec_bin_ = exec_bin;
  if (exec_bin) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nsjail.NsJailConfig.exec_bin)
}
inline ::nsjail::Exe* NsJailConfig::release_exec_bin() {
  _has_bits_[0] &= ~0x00100000u;
  ::nsjail::Exe* temp = exec_bin_;
  exec_bin_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::nsjail::Exe* NsJailConfig::unsafe_arena_release_exec_bin() {
  // @@protoc_insertion_point(field_release:nsjail.NsJailConfig.exec_bin)
  _has_bits_[0] &= ~0x00100000u;
  ::nsjail::Exe* temp = exec_bin_;
  exec_bin_ = nullptr;
  return temp;
}
inline ::nsjail::Exe* NsJailConfig::_internal_mutable_exec_bin() {
  _has_bits_[0] |= 0x00100000u;
  if (exec_bin_ == nullptr) {
    auto* p = CreateMaybeMessage<::nsjail::Exe>(GetArena());
    exec_bin_ = p;
  }
  return exec_bin_;
}
inline ::nsjail::Exe* NsJailConfig::mutable_exec_bin() {
  // @@protoc_insertion_point(field_mutable:nsjail.NsJailConfig.exec_bin)
  return _internal_mutable_exec_bin();
}
inline void NsJailConfig::set_allocated_exec_bin(::nsjail::Exe* exec_bin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete exec_bin_;
  }
  if (exec_bin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(exec_bin);
    if (message_arena != submessage_arena) {
      exec_bin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exec_bin, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  exec_bin_ = exec_bin;
  // @@protoc_insertion_point(field_set_allocated:nsjail.NsJailConfig.exec_bin)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nsjail

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::nsjail::Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsjail::Mode>() {
  return ::nsjail::Mode_descriptor();
}
template <> struct is_proto_enum< ::nsjail::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsjail::LogLevel>() {
  return ::nsjail::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::nsjail::RLimit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsjail::RLimit>() {
  return ::nsjail::RLimit_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_config_2eproto
